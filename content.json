{"meta":{"title":"Mayanming Blog","subtitle":"","description":"","author":"Mayanming(Marco)","url":"https://mayanming.com","root":"/"},"pages":[{"title":"","date":"2020-12-12T05:52:50.759Z","updated":"2020-12-12T05:52:50.759Z","comments":true,"path":"404.html","permalink":"https://mayanming.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"Vue 父子组件之间传值","slug":"Vue-component-parameter","date":"2021-01-13T02:46:14.000Z","updated":"2021-01-13T03:31:24.669Z","comments":true,"path":"2021/01/13/Vue-component-parameter/","link":"","permalink":"https://mayanming.com/2021/01/13/Vue-component-parameter/","excerpt":"Vue 父组件与子组件之间的参数传递解析","text":"Vue 父组件与子组件之间的参数传递解析 Vue 父组件=&gt;子组件（动态传值)遇到问题前提uni-app框架，项目需要父组件接口获取数据后(动态)传值并调用子组件，一直都是空值，甚至打印长度为0，数据却显示长度不为0。 方法一：props传值，传过来的值需要用watch监听并更新，否则为空值原因数据还没有被赋值的时候，子组件就已经显示在页面上了 父组件（template） &lt;shmily-drag-image :list=&quot;dataImgList&quot;&gt;&lt;/shmily-drag-image&gt; 父组件 （script） this.dataImgList=res.data.imgList; //参数赋值 这里把接口返回的数组赋值给this.dataImgList，然后把该数组传给子组件定义的props属性list 子组件（props） props: &#123; list: &#123; type: Array, default: function() &#123; return [] &#125; &#125; &#125; 子组件 (watch：监听数据变化) watch:&#123; list(newVal,oldVal)&#123; if(newVal)&#123; this.sonImgList=curVal; &#125; &#125;, &#125; 此方法数据 this.list 数据进行父组件子组件绑定 方法二：通过ref属性，父组件调用子组件的方法，把要传的数组作为参数传给子组件，子组件获取该参数，并使用 父组件（template） &lt;shmily-drag-image ref=&quot;fatherImgList&quot; :list=&quot;dataImgList&quot; &gt;&lt;/shmily-drag-image&gt; 父组件 （script） this.$refs.fatherImgList.getSrcList(this.dataImgList); 子组件（script） getSrcList(val)&#123; this.sonImgList=val; &#125;, 子组件向父组件传值，如果是动态改变的，也要记得加watch函数，动态改变之后执行的操作写在watch里，比如 this.$emit的函数！","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://mayanming.com/tags/Vue/"}]},{"title":"使用jsDelivr 开源公共 CDN","slug":"use-cdn","date":"2020-12-12T03:34:59.000Z","updated":"2020-12-12T04:20:06.041Z","comments":true,"path":"2020/12/12/use-cdn/","link":"","permalink":"https://mayanming.com/2020/12/12/use-cdn/","excerpt":"记录使用开源公共CDN，通过Github+jsDelivr 将资源CDN加速","text":"记录使用开源公共CDN，通过Github+jsDelivr 将资源CDN加速 新建Github仓库 连接Github仓库在本地目录右键 Git Bash Here，执行以下命令： git clone 你的CDN仓库地址 上传你所需要加速资源复制需要上传的资源到本地git仓库 （注：jsDelivr不支持加载超过20M的资源），在本地存放需加速资源git仓库目录下右键 Git Bash Here，执行以下命令： git status //查看状态 git add . //添加所有文件到暂存区 git commit -m &#39;提交的描述&#39; //把文件提交到仓库 git push //推送至远程仓库 发布仓库在github 你的CDN加速仓库里面的项目里面点击 Releases 发布 进入可设置版本号 使用jsDelivr引用资源使用方法 https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载任何Github发布、提交或分支 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 完全省略该版本以获取最新版本","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://mayanming.com/tags/CDN/"}]},{"title":"前端页面性能优化","slug":"postpage-optimization","date":"2019-10-03T03:34:59.000Z","updated":"2021-01-07T02:47:21.129Z","comments":true,"path":"2019/10/03/postpage-optimization/","link":"","permalink":"https://mayanming.com/2019/10/03/postpage-optimization/","excerpt":"页面优化以及方向","text":"页面优化以及方向 1.资源压缩合并，减少Http请求 合并图片，css,js文件合并，css,js压缩 图片较多可以使用lazyLoad(懒加载)等技术优化 使用精灵图，SVG图片，或iconfont等 2.非核心代码异步加载 异步加载的方式(不含框架，只是原理) 1.动态脚本加载2.defer3.async 1动态脚本加载：使用document.createElement创建一个script标签，即document.createElement‘script′，在需要的时候调用。 &lt;script&gt; document.createElement(&quot;&lt;script src=&#39;a.js&#39;&gt;&lt;\\/script&gt;&quot;); &lt;/script&gt; 2.defer通过异步的方式加载defer1.js文件： &lt;script&gt; &lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt; &lt;/script&gt; 3async： &lt;script&gt; &lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt; &lt;/script&gt; defer和async的区别： defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。 async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。 3.利用浏览器缓存浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；缓存分为： 强缓存 协商缓存 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"https://mayanming.com/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"Ajax基础详解","slug":"ajax","date":"2019-09-27T06:39:05.000Z","updated":"2020-12-13T11:46:35.923Z","comments":true,"path":"2019/09/27/ajax/","link":"","permalink":"https://mayanming.com/2019/09/27/ajax/","excerpt":"客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术Ajax的核心是js对象：XMLHttpRequest。","text":"客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术Ajax的核心是js对象：XMLHttpRequest。 什么是Ajax 同步: 客户端发起请求–等待–>服务器端处理—等待–>响应–>页面载入 请求错误时全部重新载入. 同步例子（在银行排队时，只有等到你了，才能够去处理-业务。） 异步: 客户端发起请求—>服务器端处理—>响应—>页面载入填写时 即时更新,部分返回. 异步例子 （在排队的时候，可以玩手机。） 发送 Ajax 请求的五个步骤 1234561.创建异步对象。即 XMLHttpRequest 对象。2.使用open方法设置请求的参数。openmethod,url,async。参数解释：请求的方法、请求的url、是否异步。3.发送请求。4.注册事件。 注册onreadystatechange事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。5.获取返回的数据。 XMLHttpRequest要创建XMLHttpRequest对象是要分两种情况考虑的： 在IE6以下的版本 在IE6以上的版本以及其他内核的浏览器Mozilla等 12345678910 &lt;script type=&quot;text/javascript&quot;&gt; var httpRequest; if(window.XMLHttpRequest) &#123; //在IE6以上的版本以及其他内核的浏览器(Mozilla)等 httpRequest = new XMLHttpRequest(); &#125;else if(window.ActiveXObject) &#123; //在IE6以下的版本 httpRequest = new ActiveXObject(); &#125;&lt;/script&gt; 了解XMLHttpRequest对象的方法 1.open(String method,String url,boolean asynch,String username,String password)2.sendcontent3.setRequestHeaderStringheader,Stringvalue4.getAllResponseHeaders5.getResponseHeaderStringheader6.abort 解析XMLHttpRequest对象的方法的常用类：open：该方法创建http请求 1.第一个参数是指定提交方式post、get 2.第二个参数是指定要提交的地址是哪 3.第三个参数是指定是异步还是同步true表示异步，false表示同步 4.第四个参数获取所有的响应报头,http认证的时候会用到,是可选的 5.第五个参数查询响应中的某个字段的值参数在http认证的时候会用到,是可选的 setRequestHeaderStringheader,Stringvalue：设置消息头（使用post方式才会使用到，get方法并不需要调用该方法） xmlhttp.setRequestHeader“Content−type”,”application/x−www−form−urlencoded”; sendcontent：发送请求给服务器 如果是get方式，并不需要填写参数，或填写null 如果是post方式，把要提交的参数写上去 了解XMLHttpRequest对象的属性 1.onreadystatechange：请求状态改变的事件触发器（readyState变化时会调用此方法）,一般用于指定回调函数(通过监听onreadystatechange事件,来判断请求的状态.) 2.readyState readyState：请求状态readyState一改变，回调函数被调用，它有5个状态0：未初始化还没有调用open(方法)1：open方法成功调用以后已调用send(方法,正在发送请求)2：载入完成,服务器已经应答客户端的请求send(方法完成,已经收到全部响应 内容)3：交互中解析。Http头信息已经接收，响应数据尚未接收。正在解析响应内容4：完成。数据接收完成响应内容解析完成,可以在客户端调用了 基本完整的一个Ajax请求 1234567891011var request = new XMLHttpRequest();request.open(&quot;GET&quot;,&quot;get.json&quot;,true); request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; //响应成功,做一些事情 &#125; else &#123; //响应失败,做一些事情 &#125; &#125; &#125;; ajax响应流程图 1.responseText：服务器返回的文本内容2.responseXML：服务器返回的兼容DOM的XML内容3.status：服务器返回的状态码4.statusText：服务器返回状态码的文本信息 ajax响应流程图 回调函数就是接收 服务器返回的内容 编写第一个Ajax程序html代码 创建的div只要用于显示服务器返回的数据 当用户点击按钮的时候，就触发事件。 &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;checkUsername()&quot; value=&quot;检测用户名是否合法&quot;&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; JavaScript代码 &lt;script type=&quot;text/javascript&quot;&gt; var httpRequest; function checkUsername() &#123; if(window.XMLHttpRequest) &#123; //在IE6以上的版本以及其他内核的浏览器(Mozilla)等 httpRequest = new XMLHttpRequest(); &#125;else if(window.ActiveXObject) &#123; //在IE6以下的版本 httpRequest = new ActiveXObject(); &#125; //创建http请求 httpRequest.open(&quot;POST&quot;, &quot;Servlet1&quot;, true); //因为我使用的是post方式，所以需要设置消息头 httpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); //指定回调函数 httpRequest.onreadystatechange = responseOk; //得到文本框的数据 var name = document.getElementById(&quot;username&quot;).value; //发送http请求，把要检测的用户名传递进去 httpRequest.send(&quot;username=&quot; + name); &#125; function responseOk() &#123; //判断请求状态码是否是4【数据接收完成】 if(httpRequest.readyState==4) &#123; //再判断状态码是否为200【200是成功的】 if(httpRequest.status==200) &#123; //得到服务端返回的文本数据 var text = httpRequest.responseText; //把服务端返回的数据写在div上 var div = document.getElementById(&quot;result&quot;); div.innerText = text; &#125; &#125; &#125; XMLHttpRequest解决缓存问题在传统的Web中我们也解决过缓存的问题，通过设置response的头信息，返回给浏览器就可以实现不缓存页面了。但是呢，现在我们使用XMLHttpRequest，拿到的不是全新的页面，仅仅是服务器端发送过来的数据！！那我们要怎么解决缓存的问题呢？？产生缓存的原因就是：我们请求了同一个地址，做了相同的操作。服务端认为我的操作并没有什么变化，就直接把缓存的信息给我了。这样的话，我就不能更换验证码图片了等等应用。添加时间戳即可解决","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://mayanming.com/tags/Ajax/"}]},{"title":"Hexo博客搭建","slug":"use-hexo","date":"2019-09-01T06:39:05.000Z","updated":"2020-12-13T03:00:30.176Z","comments":true,"path":"2019/09/01/use-hexo/","link":"","permalink":"https://mayanming.com/2019/09/01/use-hexo/","excerpt":"从零开始开始搭建属于自己的Hexo个人博客","text":"从零开始开始搭建属于自己的Hexo个人博客 搭建Hexo博客 - Github搭建Hexo博客 - Github 大体流程： 环境安装检测 开始搭建Hexo 本地项目连接Github 本地上传文章，发布文章 源码备份 新电脑恢复数据 环境安装检测1node -v 1npm -v 各自出现序列号说明环境已安装完成并且安装：Git Git官网安装https://git-scm.com/downloads 开始搭建Hexo本地合适的地方新建一个文件夹在该目录右键点击 Git Bash Here,打开git的控制窗口，就不用再windows 自带的运行窗口进行了 1npm i hexo-cli -g 安装hexo基础模块 123456789hexo -vhexo initnpm installhexo ghexos 打开本地服务器，出现 http://localhost:4000/ 则完成安装 本地项目连接Github1.对着目标文件夹右键 git bash,然后输入下面命令 123git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 2.生成密匙SSH key 1ssh-keygen -t rsa -C &quot;注册邮箱&quot; 3.一直默认回车 然后git bash 1cat ~/.ssh/id_rsa.pub 4.将输出内容处置到Github 账号设置里面的SSH key 1ssh -T git@github.com 5.在git bash 输入出现你的用户名等信息就是成功了6.在博客 根目录 _config.yml 文件配置信息 本地上传文章，发布文章生成文章文件，以及基础配置 1hexo new post &quot;名称&quot; 上传到github上 123hexo cleanhexo ghexo d 源码备份使用Hexo在github搭建的博客，博客作为一个单独的GitHub仓库存在，但是这个仓库只有生成的静态网页文件，并没有Hexo的源文件，如果要换电脑或者重装系统后，就比较麻烦了，这里推荐一种方法。 1.创建两个分支：master和hexo2.github上设置hexo为默认分支；3.在Username.github.io文件夹执行npm install和npm install hexo-deployer-git（这里可以看一看分支是不是显示为hexo）4.执行 git add . 、 git commit -m “这次提交的描述” 、git push origin hexo来提交hexo网站 源文件；5.执行hexo g -d生成静态网页部署至Github上。 这样做法，github仓库就有master 和 hexo 分支，分别保存静态网页跟源文件 新电脑恢复数据使用 git clone 你的github静态部署文件hexo 将仓库拷至本地； 123npm install hexo-cli -gnpm installnpm install hexo-deployer-git 最后重新添加SSH 12345678910111 ._config.yml站点的配置文件，需要拷贝 2 .themes/主题文件夹，需要拷贝； 3 .source博客文章的.md文件，需要拷贝； 4 .scaffolds/文章的模板，需要拷贝； 5 .package.json安装包的名称，需要拷贝； 6 .gitignore限定在push时哪些文件可以忽略，需要拷贝； 7 .git/主题和站点都有，标志这是一个git项目，不需要拷贝； 8 node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； 9 public是hexo g生成的静态网页，不需要拷贝； 10 .deploy_git同上，hexo g也会生成，不需要拷贝； 11 db.json文件，不需要拷贝。 其实不需要拷贝的文件正是 .gitignore 文件中所忽略的。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mayanming.com/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://mayanming.com/tags/Vue/"},{"name":"CDN","slug":"CDN","permalink":"https://mayanming.com/tags/CDN/"},{"name":"优化","slug":"优化","permalink":"https://mayanming.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"Ajax","slug":"Ajax","permalink":"https://mayanming.com/tags/Ajax/"},{"name":"Hexo","slug":"Hexo","permalink":"https://mayanming.com/tags/Hexo/"}]}