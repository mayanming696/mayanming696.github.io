---
title: 页面性能优化
top: false
cover: false
toc: true
mathjax: true
date: 2018-09-26 14:48:44
password:
summary: Web学习
tags:
- Web学习
categories:
- Web学习
---

**前言页面性能优化**

>提升页面性能优化的方法有哪些：

* 1.资源压缩合并，减少http请求
* 2.非核心代码异步加载 --> 异步加载的方式 --> 异步加载的区别
* 3.利用浏览器缓存 --> 缓存的分类 --> 缓存的原理(缓存是所有性能优化的方式中最重要的一步)
有的人可能会回答local storage 和session storage，其实不是这个。浏览器缓存和存储不是一回事。
* 4.使用CDN **(浏览器第一次打开页面时，缓存是起不了作用的)**
* 5.DNS预解析

---

# 一、资源压缩合并，减少http请求

* 合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩
* 图片较多的页面也可以使用 lazyLoad 等技术进行优化。
* 精灵图、svg图等

---

# 二、非核心代码异步加载

异步加载的方式：（这里不说框架，只说原理）
* 动态脚本加载
* defer
* async

## **动态脚本加载**

使用document.createElement创建一个script标签，即document.createElement('script')，在需要的时候调用。

    <script>
    document.createElement("<script src='a.js'><\/script>");
    </script>

## defer

通过异步的方式加载defer1.js文件：

    
    <script src="./defer1.js" defer></script>


## async 

>HTmL5新增特性。

通过异步的方式加载async1.js文件：

    <script src="./async1.js" async></script>

defer和async的区别
* defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。
* async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。

---

# 三、利用浏览器缓存
浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。
缓存：资源文件（比如图片）在本地的硬盘里存有副本，浏览器下次请求的时候，可能直接从本地磁盘里读取，而不会重新请求图片的url。


**浏览器缓存基本认识**

* 1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
缓存分为：

* 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；

* 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

* 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。


## 强缓存

强缓存原理：当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：

![](1.png)

强缓存是利用 http 响应头中的**Expires(较老的强缓存管理)或Cache-Control(管理更有效，安全)**实现的。它们都用来表示资源在客户端缓存的有效期。

+ 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：

![](2.png)

+ 2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）

+ 3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。

+ 4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。

> **注意：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-Control同时存在时，Cache-Control的优先级高于Expires。**

![](3.png)

下面讲一下二者的区别。

+ 1、Expires：服务器返回的绝对时间。

是较老的强缓存管理 response header。浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires的时间之前，就能命中缓存，否则就不行。

如果缓存没有命中，浏览器直接从服务器请求资源时，Expires Header在重新请求的时候会被更新。

缺点：

由于Expires是服务器返回的一个绝对时间，存在的问题是：服务器的事件和客户端的事件可能不一致。在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改客户端时间，就能影响缓存命中的结果。所以，在http1.1中，提出了一个新的response header，就是Cache-Control。

+ 2、Cache-Control：服务器返回的相对时间。

http1.1中新增的 response header。浏览器第一次请求资源之后，在接下来的相对时间之内，都可以利用本地缓存。超出这个时间之后，则不能命中缓存。重新请求时，Cache-Control会被更新。

**前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：**

+ 1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；
+ 2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。

## 协商缓存

协商缓存：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：

![](4.png)

查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：

![](5.png)

**协商缓存是利用的是两对Header**

+ 第一对：Last-Modified、If-Modified-Since

+ 第二对：ETag、If-None-Match

### 【Last-Modified，If-Modified-Since】的控制缓存的原理是：

+ 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：

![](5.png)

+ 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：

![](6.png)

+ 3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：

![](7.png)

+ 4）浏览器收到304的响应后，就会从缓存中加载资源。

+ 5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。

>**缺点：**
Last-Modified、If-Modified-Since一般来说都是非常可靠的，但面临的问题是：
* 服务器上的资源变化了，但是最后的修改时间却没有变化。
* 如果服务器端在一秒内修改文件两次，但产生的Last-Modified却只有一个值。

**这一对header就无法解决这种情况。于是，下面这一对header出场了。**


### 【ETag、If-None-Match。过程如下】的控制缓存的原理是：

+ 1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：

![](8.png)

+ 2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：

![](9.png)

+ 3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：

![](10.png)

+ 4）浏览器收到304的响应后，就会从缓存中加载资源。


## 协商缓存管理

协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:

![](11.png)

如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。
分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；
分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；
京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：

![](12.png)

**协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。**

## 浏览器行为对缓存的影响

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：

+ 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
+ 当f5刷新网页时，跳过强缓存，但是会检查协商缓存；


---

# 四、使用CDN

怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。
要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。

---

# 五、DNS预解析（dns-prefetch）

通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。

**第一步：**打开或关闭DNS预解析
你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签：

    <meta http-equiv="x-dns-prefetch-control" content="on">

需要说明的是，在一些高级浏览器中，页面中所有的超链接（**<a>**标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方）

**第二步：**对指定的域名进行DNS预解析
如果我们将来可能从 **https://github.com** 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：

    <link rel="dns-prefetch" href="https://github.com">

当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。    





