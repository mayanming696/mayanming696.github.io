<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 父子组件之间传值</title>
      <link href="2021/01/13/Vue-component-parameter/"/>
      <url>2021/01/13/Vue-component-parameter/</url>
      
        <content type="html"><![CDATA[<p>Vue 父子组件之间的参数传递解析</p><a id="more"></a><h2 id="Vue-父组件-gt-子组件（动态传值"><a href="#Vue-父组件-gt-子组件（动态传值" class="headerlink" title="Vue 父组件=&gt;子组件（动态传值)"></a>Vue 父组件=&gt;子组件（动态传值)</h2><p>遇到问题前提uni-app框架，项目需要父组件接口获取数据后(动态)传值并调用子组件，一直都是空值，甚至打印长度为0，数据却显示长度不为0。</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>props传值，传过来的值需要用watch监听并更新，否则为<span class='p red'>空值</span><br>原因数据还没有被赋值的时候，子组件就已经显示在页面上了</p><pre><code class="bash">父组件（template） &lt;shmily-drag-image :list=&quot;dataImgList&quot;&gt;&lt;/shmily-drag-image&gt;父组件 （script）this.dataImgList=res.data.imgList; //参数赋值</code></pre><p>这里把接口返回的数组赋值给<br>this.dataImgList，然后把该数组传给子组件定义的props属性list</p><pre><code class="bash">子组件（props）   props: &#123;    list: &#123;      type: Array,      default: function() &#123;        return []      &#125;    &#125;   &#125;子组件 (watch：监听数据变化)watch:&#123;    list(newVal,oldVal)&#123;     if(newVal)&#123;       this.sonImgList=curVal;      &#125;   &#125;,&#125;</code></pre><p>此方法数据 this.list 数据进行父组件子组件绑定</p><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>通过ref属性，父组件调用子组件的方法，把要传的数组作为参数传给子组件，子组件获取该参数，并使用</p><pre><code class="bash">父组件（template）&lt;shmily-drag-image ref=&quot;fatherImgList&quot;  :list=&quot;dataImgList&quot; &gt;&lt;/shmily-drag-image&gt;父组件 （script）this.$refs.fatherImgList.getSrcList(this.dataImgList); </code></pre><pre><code class="bash">子组件（script）    getSrcList(val)&#123;        this.sonImgList=val;    &#125;,</code></pre><p>子组件向父组件传值，如果是动态改变的，也要记得加<span class='p red'>watch</span>函数，动态改变之后执行的操作写在watch里，比如 <span class='p red'>this.$emit</span>的函数！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用jsDelivr 开源公共 CDN</title>
      <link href="2020/12/12/use-cdn/"/>
      <url>2020/12/12/use-cdn/</url>
      
        <content type="html"><![CDATA[<p>记录使用开源公共CDN，通过Github+jsDelivr 将资源CDN加速</p><a id="more"></a><h2 id="新建Github仓库"><a href="#新建Github仓库" class="headerlink" title="新建Github仓库"></a>新建Github仓库</h2><p><img src="new-Github.jpg" class="lazyload" data-srcset="new-Github.jpg" srcset="data:image/png;base64,666" alt="新建githun仓库"></p><h2 id="连接Github仓库"><a href="#连接Github仓库" class="headerlink" title="连接Github仓库"></a>连接Github仓库</h2><p>在本地目录右键 Git Bash Here，执行以下命令：</p><pre><code class="bash">git clone 你的CDN仓库地址</code></pre><h2 id="上传你所需要加速资源"><a href="#上传你所需要加速资源" class="headerlink" title="上传你所需要加速资源"></a>上传你所需要加速资源</h2><p>复制需要上传的资源到本地git仓库 <span class='p blue'>（注：jsDelivr不支持加载超过20M的资源）</span>，<br>在本地存放需加速资源git仓库目录下右键 Git Bash Here，执行以下命令：</p><pre><code class="bash">git status //查看状态git add .  //添加所有文件到暂存区git commit -m &#39;提交的描述&#39;   //把文件提交到仓库git push   //推送至远程仓库</code></pre><h2 id="发布仓库"><a href="#发布仓库" class="headerlink" title="发布仓库"></a>发布仓库</h2><p>在github 你的CDN加速仓库里面的项目里面点击 <span class='p red'>Releases</span> 发布</p><ul><li>进入可设置版本号</li></ul><h2 id="使用jsDelivr引用资源"><a href="#使用jsDelivr引用资源" class="headerlink" title="使用jsDelivr引用资源"></a>使用jsDelivr引用资源</h2><p>使用方法 <span class='p red'>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span> </p><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><pre><code class="bash">https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js // 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js  // 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 完全省略该版本以获取最新版本</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端页面性能优化</title>
      <link href="2019/10/03/postpage-optimization/"/>
      <url>2019/10/03/postpage-optimization/</url>
      
        <content type="html"><![CDATA[<p>页面优化以及方向</p><a id="more"></a><h2 id="1-资源压缩合并，减少Http请求"><a href="#1-资源压缩合并，减少Http请求" class="headerlink" title="1.资源压缩合并，减少Http请求"></a>1.资源压缩合并，减少Http请求</h2><ul><li>合并图片，css,js文件合并，css,js压缩</li><li>图片较多可以使用lazyLoad(懒加载)等技术优化</li><li>使用精灵图，SVG图片，或iconfont等</li></ul><h2 id="2-非核心代码异步加载"><a href="#2-非核心代码异步加载" class="headerlink" title="2.非核心代码异步加载"></a>2.非核心代码异步加载</h2><details cyan blue><summary> 异步加载的方式(不含框架，只是原理) </summary>              <div class='content'>              <p>1.动态脚本加载<br>2.defer<br>3.async</p>              </div>            </details><p>1动态脚本加载：<br>使用document.createElement创建一个script标签，即document.createElement‘script′，在需要的时候调用。</p><pre><code class="bash">&lt;script&gt;document.createElement(&quot;&lt;script src=&#39;a.js&#39;&gt;&lt;\/script&gt;&quot;);&lt;/script&gt;</code></pre><p>2.defer<br>通过异步的方式加载defer1.js文件：</p><pre><code class="bash">&lt;script&gt;&lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;&lt;/script&gt;</code></pre><p>3async：</p><pre><code class="bash">&lt;script&gt;&lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt;&lt;/script&gt;</code></pre><span class='p red'>defer和async的区别：</span><ul><li>defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。</li><li>async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。</li></ul><h2 id="3-利用浏览器缓存"><a href="#3-利用浏览器缓存" class="headerlink" title="3.利用浏览器缓存"></a>3.利用浏览器缓存</h2><p>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。<br>比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；<br>缓存分为：</p><ul><li>强缓存</li><li>协商缓存</li></ul><p>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。</p><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax基础详解</title>
      <link href="2019/09/27/ajax/"/>
      <url>2019/09/27/ajax/</url>
      
        <content type="html"><![CDATA[<div class="note success"><p>客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术Ajax的核心是js对象：XMLHttpRequest。</p></div><a id="more"></a><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li><span class='p red'>同步</span>: <span class='p blue'>客户端发起请求–等待–>服务器端处理—等待–>响应–>页面载入</span> 请求错误时全部重新载入.</li><li><ul><li>同步例子（在银行排队时，只有等到你了，才能够去处理-业务。）</li></ul></li><li><span class='p red'>异步</span>: <span class='p blue'>客户端发起请求—>服务器端处理—>响应—>页面载入填写时</span> 即时更新,部分返回.</li><li><ul><li>异步例子 （在排队的时候，可以玩手机。）</li></ul></li></ul><details cyan open><summary> 发送 Ajax 请求的五个步骤 </summary>              <div class='content'>              <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建异步对象。即 XMLHttpRequest 对象。</span><br><span class="line">2.使用open方法设置请求的参数。openmethod,url,async。参数解释：请求的方法、请求的url、是否异步。</span><br><span class="line">3.发送请求。</span><br><span class="line">4.注册事件。 注册onreadystatechange事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，</span><br><span class="line">我们需要手动写一些判断的逻辑。</span><br><span class="line">5.获取返回的数据。</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>要创建XMLHttpRequest对象是要分两种情况考虑的：</p><ul><li>在IE6以下的版本</li><li>在IE6以上的版本以及其他内核的浏览器Mozilla等</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    var httpRequest;</span><br><span class="line">        <span class="keyword">if</span>(window.XMLHttpRequest) &#123;</span><br><span class="line">            //在IE6以上的版本以及其他内核的浏览器(Mozilla)等</span><br><span class="line">            httpRequest = new XMLHttpRequest();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(window.ActiveXObject) &#123;</span><br><span class="line">            //在IE6以下的版本</span><br><span class="line">            httpRequest = new ActiveXObject();</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><details cyan><summary> 了解XMLHttpRequest对象的方法 </summary>              <div class='content'>              <p>1.open(String method,String url,boolean asynch,String username,String password)<br>2.sendcontent<br>3.setRequestHeaderStringheader,Stringvalue<br>4.getAllResponseHeaders<br>5.getResponseHeaderStringheader<br>6.abort</p>              </div>            </details><p>解析XMLHttpRequest对象的方法的常用类：<br>open：该方法创建http请求</p><ul><li>1.第一个参数是指定提交方式post、get</li><li>2.第二个参数是指定要提交的地址是哪</li><li>3.第三个参数是指定是异步还是同步true表示异步，false表示同步</li><li>4.第四个参数获取所有的响应报头,http认证的时候会用到,是可选的</li><li>5.第五个参数查询响应中的某个字段的值参数在http认证的时候会用到,是可选的</li></ul><p>setRequestHeaderStringheader,Stringvalue：设置消息头（使用post方式才会使用到，get方法并不需要调用该方法）</p><ul><li>xmlhttp.setRequestHeader“Content−type”,”application/x−www−form−urlencoded”;</li></ul><p>sendcontent：发送请求给服务器</p><ul><li>如果是get方式，并不需要填写参数，或填写null</li><li>如果是post方式，把要提交的参数写上去</li></ul><details cyan><summary> 了解XMLHttpRequest对象的属性 </summary>              <div class='content'>              <p>1.onreadystatechange：</p><ul><li>请求状态改变的事件触发器（readyState变化时会调用此方法）,一般用于指定回调函数(通过监听onreadystatechange事件,来判断请求的状态.)</li></ul><details cyan yellow><summary> 2.readyState </summary>              <div class='content'>              <p>readyState：请求状态readyState一改变，回调函数被调用，它有5个状态</p><ul><li>0：未初始化还没有调用open(方法)</li><li>1：open方法成功调用以后已调用send(方法,正在发送请求)</li><li>2：载入完成,服务器已经应答客户端的请求send(方法完成,已经收到全部响应 内容)</li><li>3：交互中解析。Http头信息已经接收，响应数据尚未接收。正在解析响应内容</li><li>4：完成。数据接收完成响应内容解析完成,可以在客户端调用了</li></ul>              </div>            </details>              </div>            </details><p>基本完整的一个Ajax请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var request = new XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;get.json&quot;</span>,<span class="literal">true</span>); </span><br><span class="line">request.onreadystatechange = <span class="function"><span class="title">function</span></span> () &#123; </span><br><span class="line">    <span class="keyword">if</span> (request.readyState === 4) &#123; </span><br><span class="line">        <span class="keyword">if</span> (request.status === 200) &#123; </span><br><span class="line">            //响应成功,做一些事情 </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 //响应失败,做一些事情 </span><br><span class="line">                 &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><details cyan open><summary> ajax响应流程图 </summary>              <div class='content'>              <p><img src="ajax%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="ajax%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,666" alt="Ajax流程示意图"></p><ul><li>1.responseText：服务器返回的文本内容</li><li>2.responseXML：服务器返回的兼容DOM的XML内容</li><li>3.status：服务器返回的状态码</li><li>4.statusText：服务器返回状态码的文本信息</li></ul>              </div>            </details><details cyan open><summary> ajax响应流程图 </summary>              <div class='content'>              <p><img src="Ajax%E8%BF%94%E5%9B%9E%E7%9A%84%E5%86%85%E5%AE%B9.png" class="lazyload" data-srcset="Ajax%E8%BF%94%E5%9B%9E%E7%9A%84%E5%86%85%E5%AE%B9.png" srcset="data:image/png;base64,666" alt="Ajax返回的内容"></p><p>回调函数就是接收 <span class='p red'>服务器返回的内容</span></p>              </div>            </details><h2 id="编写第一个Ajax程序"><a href="#编写第一个Ajax程序" class="headerlink" title="编写第一个Ajax程序"></a>编写第一个Ajax程序</h2><p>html代码</p><ul><li>创建的div只要用于显示服务器返回的数据</li><li>当用户点击按钮的时候，就触发事件。</li></ul><pre><code class="bash">    &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;    &lt;input type=&quot;button&quot; onclick=&quot;checkUsername()&quot; value=&quot;检测用户名是否合法&quot;&gt;    &lt;div id=&quot;result&quot;&gt;    &lt;/div&gt;</code></pre><p>JavaScript代码</p><pre><code class="bash">&lt;script type=&quot;text/javascript&quot;&gt;    var httpRequest;    function checkUsername() &#123;        if(window.XMLHttpRequest) &#123;            //在IE6以上的版本以及其他内核的浏览器(Mozilla)等            httpRequest = new XMLHttpRequest();        &#125;else if(window.ActiveXObject) &#123;             //在IE6以下的版本            httpRequest = new ActiveXObject();        &#125;        //创建http请求        httpRequest.open(&quot;POST&quot;, &quot;Servlet1&quot;, true);        //因为我使用的是post方式，所以需要设置消息头        httpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);        //指定回调函数        httpRequest.onreadystatechange = responseOk;        //得到文本框的数据        var name = document.getElementById(&quot;username&quot;).value;        //发送http请求，把要检测的用户名传递进去        httpRequest.send(&quot;username=&quot; + name);    &#125;    function responseOk() &#123;         //判断请求状态码是否是4【数据接收完成】          if(httpRequest.readyState==4) &#123;            //再判断状态码是否为200【200是成功的】            if(httpRequest.status==200) &#123;                //得到服务端返回的文本数据                var text = httpRequest.responseText;                //把服务端返回的数据写在div上                var div = document.getElementById(&quot;result&quot;);                div.innerText = text;            &#125;          &#125;    &#125;</code></pre><h2 id="XMLHttpRequest解决缓存问题"><a href="#XMLHttpRequest解决缓存问题" class="headerlink" title="XMLHttpRequest解决缓存问题"></a>XMLHttpRequest解决缓存问题</h2><p>在传统的Web中我们也解决过缓存的问题，通过设置response的头信息，返回给浏览器就可以实现不缓存页面了。<br>但是呢，现在我们使用XMLHttpRequest，拿到的不是全新的页面，仅仅是服务器端发送过来的数据！！<br>那我们要怎么解决缓存的问题呢？？产生缓存的原因就是：我们请求了同一个地址，做了相同的操作。服务端认为我的操作并没有什么变化，就直接把缓存的信息给我了。这样的话，我就不能更换验证码图片了等等应用。<span class='p red'>添加时间戳即可解决</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="2019/09/01/use-hexo/"/>
      <url>2019/09/01/use-hexo/</url>
      
        <content type="html"><![CDATA[<p>从零开始开始搭建属于自己的Hexo个人博客</p><a id="more"></a><h2 id="搭建Hexo博客-Github"><a href="#搭建Hexo博客-Github" class="headerlink" title="搭建Hexo博客 - Github"></a>搭建Hexo博客 - Github</h2><p>搭建Hexo博客 - Github 大体流程：</p><ul><li>环境安装检测</li><li>开始搭建Hexo</li><li>本地项目连接Github</li><li>本地上传文章，发布文章</li><li>源码备份</li><li>新电脑恢复数据</li></ul><h2 id="环境安装检测"><a href="#环境安装检测" class="headerlink" title="环境安装检测"></a>环境安装检测</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>各自出现序列号说明环境已安装完成<br>并且安装：<span class='p red'>Git</span></p><div class="tag link"><a class="link-card" title="Git官网安装" href="https://git-scm.com/downloads"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">Git官网安装</p><p class="url">https://git-scm.com/downloads</p></div></a></div><h2 id="开始搭建Hexo"><a href="#开始搭建Hexo" class="headerlink" title="开始搭建Hexo"></a>开始搭建Hexo</h2><p>本地合适的地方新建一个文件夹<br>在该目录右键点击 <span class='p red'>Git Bash Here</span>,打开git的控制窗口，就不用再windows 自带的运行窗口进行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装hexo基础模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexos</span><br></pre></td></tr></table></figure><p>打开本地服务器，出现 <a href="http://localhost:4000/">http://localhost:4000/</a> 则完成安装</p><h2 id="本地项目连接Github"><a href="#本地项目连接Github" class="headerlink" title="本地项目连接Github"></a>本地项目连接Github</h2><p>1.对着目标文件夹右键 <span class='p red'>git bash</span>,然后输入下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>2.生成密匙SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>3.一直默认回车 然后<span class='p red'>git bash</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub </span><br></pre></td></tr></table></figure><p>4.将输出内容处置到Github 账号设置里面的SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>5.在git bash 输入出现你的用户名等信息就是成功了<br>6.在博客 <span class='p green'>根目录</span> <span class='p red'>_config.yml</span> 文件配置信息</p><h2 id="本地上传文章，发布文章"><a href="#本地上传文章，发布文章" class="headerlink" title="本地上传文章，发布文章"></a>本地上传文章，发布文章</h2><p>生成文章文件，以及基础配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;名称&quot;</span></span><br></pre></td></tr></table></figure><p>上传到github上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="源码备份"><a href="#源码备份" class="headerlink" title="源码备份"></a>源码备份</h2><p>使用Hexo在github搭建的博客，博客作为一个单独的GitHub仓库存在，但是这个仓库只有生成的静态网页文件，并没有Hexo的源文件，如果要换电脑或者重装系统后，就比较麻烦了，这里推荐一种方法。</p><p>1.创建两个分支：master和hexo<br>2.github上设置hexo为默认分支；<br>3.在Username.github.io文件夹执行npm install和npm install hexo-deployer-git（这里可以看一看分支是不是显示为hexo）<br>4.执行 <span class='p red'>git add .</span> 、 <span class='p red'>git commit -m “这次提交的描述”</span> 、<span class='p red'>git push origin hexo</span>来提交hexo网站 源文件；<br>5.执行hexo g -d生成静态网页部署至Github上。</p><p>这样做法，github仓库就有master 和 hexo 分支，分别保存静态网页跟源文件</p><h2 id="新电脑恢复数据"><a href="#新电脑恢复数据" class="headerlink" title="新电脑恢复数据"></a>新电脑恢复数据</h2><p>使用 git clone 你的github静态部署文件hexo 将仓库拷至本地；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>最后重新添加SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 ._config.yml站点的配置文件，需要拷贝 </span><br><span class="line">2 .themes/主题文件夹，需要拷贝； </span><br><span class="line">3 .<span class="built_in">source</span>博客文章的.md文件，需要拷贝； </span><br><span class="line">4 .scaffolds/文章的模板，需要拷贝； </span><br><span class="line">5 .package.json安装包的名称，需要拷贝； </span><br><span class="line">6 .gitignore限定在push时哪些文件可以忽略，需要拷贝； </span><br><span class="line">7 .git/主题和站点都有，标志这是一个git项目，不需要拷贝； </span><br><span class="line">8 node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； </span><br><span class="line">9 public是hexo g生成的静态网页，不需要拷贝； </span><br><span class="line">10 .deploy_git同上，hexo g也会生成，不需要拷贝； </span><br><span class="line">11 db.json文件，不需要拷贝。</span><br></pre></td></tr></table></figure><p>其实不需要拷贝的文件正是 <span class='p red'>.gitignore</span> 文件中所忽略的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
