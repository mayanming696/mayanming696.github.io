<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue-router参数传递</title>
      <link href="/2019/09/10/vue-router-can-shu-chuan-di/"/>
      <url>/2019/09/10/vue-router-can-shu-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="一、使用冒号（-）的形式传递参数-URL传递参数"><a href="#一、使用冒号（-）的形式传递参数-URL传递参数" class="headerlink" title="一、使用冒号（:）的形式传递参数(URL传递参数)"></a><strong>一、使用冒号（:）的形式传递参数(URL传递参数)</strong></h1><blockquote><p><strong>1，路由列表的参数设置</strong></p></blockquote><p>（1）路由列表的 path 是可以带参数的，我们在路由配置文件（router/index.js）里以冒号的形式设置参数。<br>（2）下面样例代码中，我在跳转到欢迎页面（/hello）时，带有两个参数 : <strong>id</strong> 和 <strong>userName</strong>。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/1.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link to=&quot;/hello/123/hangge&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push(&quot;/hello/123/hangge&quot;);</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;&lt;div&gt;    &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;    &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数成功传递并显示。</p><hr><h1 id="二、使用-query-方式传递参数-to传递，参数显示URL"><a href="#二、使用-query-方式传递参数-to传递，参数显示URL" class="headerlink" title="二、使用 query 方式传递参数(to传递，参数显示URL)"></a><strong>二、使用 query 方式传递参数(to传递，参数显示URL)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>query 方式类似 get 传参，即通过 URL 传递参数。而路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/2.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{path:&#39;/hello&#39;, query:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    path:&#39;/hello&#39;,    query:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.query.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.query.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.query.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数是自动拼接到 url 后面进行传递的。</p><hr><h1 id="三、使用-params-方式传递参数-to传递，参数不显示URL-推荐"><a href="#三、使用-params-方式传递参数-to传递，参数不显示URL-推荐" class="headerlink" title="三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)"></a><strong>三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>params 方式类似于 post 传参，即传递的参数不会显示在 URL 上。同上面的 query 方式一样，路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/3.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p> <strong>注意：params 只能用 name 来引入路由，而不能用 path。</strong><br> （1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{name:&#39;hello&#39;, params:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    name:&#39;hello&#39;,    params:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到这种方式，参数的传递不会拼接到 url 后面。</p><hr><h1 id="附：使用-props-实现参数解耦"><a href="#附：使用-props-实现参数解耦" class="headerlink" title="附：使用 props 实现参数解耦"></a>附：使用 props 实现参数解耦</h1><p> 从上面的样例可以看出，当路由携带参数跳转时，页面这边通过 <strong><em>$route.params.xxx</em></strong> 或 <strong><em>$route.query.xxx</em></strong> 来获取传递过来的数据。但这样有个问题，由于组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。<br>    要解决这个问题，我们可以使用 props 将组件和路由解耦。props 共有如下三种模式。</p><blockquote><p><strong>1，布尔模式</strong></p></blockquote><p>（1）直接将路由配置中的 props 属性被设置为 true，那么参数将会被设置为组件属性。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/4.png" alt></p><p>（2）然后我们页面组件这边不再需要通过 $route.params.xxx 或 $route.query.xxx 来获取传递过来的数据。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/5.png" alt></p><blockquote><p><strong>2，对象模式</strong></p></blockquote><p>（1）我们可以将 props 设置为一个对象，对象内容会被设置为组件属性。这种方式常用来配置静态参数。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/6.png" alt></p><p>（2）然后页面组件这边获取数据方式和前面一样。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/7.png" alt></p><blockquote><p><strong>3，函数模式</strong></p></blockquote><p>（1）我们还可以创建一个函数返回 props，在函数中对参数值进行处理，或者将静态值与基于路由的值结合。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/8.png" alt></p><p>（2）这里假设我们使用 JS 进行跳转，代码如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/9.png" alt></p><p>（3）目标页面组件代码，以及运行结果如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/10.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router路由详解</title>
      <link href="/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/"/>
      <url>/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>基本介绍</em></p></blockquote><hr><h1 id="什么是-vue-router"><a href="#什么是-vue-router" class="headerlink" title="什么是 vue-router?"></a><strong>什么是 vue-router?</strong></h1><p> (1)<strong><em>vue-router</em></strong> 是Vue官方提供前端路由插件包，借助它我们实现可以基于路由和组件的单页面应用，路径管理器<br> (2)它与传统的页面区别在于：</p><ul><li>传统的页面应用采用的是后端路由，即通过超链接来实现页面切换和跳转的。</li><li>而在 <strong><em>vue-router</em></strong> 单页面应用中，则是通过路径之间的切换（实际上就是组件的切换）。</li></ul><hr><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a><strong>安装配置</strong></h1><p> (1)如果我们使用 <strong><em>vue-cli</em></strong> 脚手架来搭建项目，在开始配置过程会选择是否需要安装路由，具体参考我之前的这篇文章：</p><ul><li><a href="/2019/09/07/vue-quan-jia-tong/">Vue.js - 使用vue-cli搭建项目（附：详细操作步骤）</a></li></ul><p>(2)如果项目搭建时没有安装也没关系，可以执行如下命令手动安装：</p><pre><code>npm install vue-router</code></pre><hr><blockquote><p><strong>路由分类</strong></p></blockquote><h1 id="1-router-link-制作导航"><a href="#1-router-link-制作导航" class="headerlink" title="1.router-link 制作导航"></a>1.router-link 制作导航</h1><ul><li><p>router-link 是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址,当然也可以使用 v-bind 来动态设置</p></li><li><p>使用 <strong><em> <router-link></router-link></em></strong>，在 HTML5 的 History 模式下会拦截点击，避免浏览器重新加载页面。</p></li><li><p>注意：被选中的router-link将自动添加一个class属性值 <strong><em>.router-link-active</em></strong></p><pre><code>  &lt;router-link to=&quot;/&quot;&gt;[text]&lt;/router-link&gt;</code></pre></li><li><p>除了 to 属性外，<router-link> 还有一些其他常用的 prop：</router-link></p><ul><li><p><strong>tag</strong> 可以指定渲染成什么标签。比如下面渲染的结果就是 <strong><em>li</em></strong> 而不是 <strong><em>a</em></strong></p><pre><code>&lt;router-link to=&quot;/hello&quot; tag=&quot;li&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p><strong>replace</strong> 配置后不会留下 History 记录，即导航后不能用后退键返回上一个页面。</p><pre><code>&lt;router-link to=&quot;/hello&quot; replace&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p>active-class</p><ul><li>当 <router-link> 对应的路由匹配成功时，会自动给当前元素设置一个名为 router-link-active 的 class。我们通常会利用它来高亮显示当前页面对应的导航菜单项。</router-link></li><li>而通过设置 active-class 可以修改默认的 class 样式名称（router-link-active），不过一般情况下我们也不需要改它，使用默认就好了。                   </li></ul></li></ul></li><li><p>to：导航路径，要填写的是你在router/index.js文件里配置的path值，<br>如果要导航到默认首页，只需要写成 to=”/“ ，</p></li><li><p>[text] ：就是我们要显示给用户的导航名称。</p></li></ul><hr><h1 id="2-router-view-用于渲染匹配到的组件"><a href="#2-router-view-用于渲染匹配到的组件" class="headerlink" title="2.router-view 用于渲染匹配到的组件"></a>2.router-view 用于渲染匹配到的组件</h1><p>会根据当前路由动态渲染不同的页面组件<br>用Vue-cli脚手架创建了项目结构，<strong><em>src文件目录下会有一个router文件夹</em></strong>,编写路由组件的地方在<br> <strong><em>编写路由组件的地方</em></strong><br><strong><em>路由的核心文件:src/router/index.js</em></strong><br> <strong><em>运行网页时，<router-view> 会根据当前路由动态渲染不同的页面组件</router-view></em></strong><br> <strong><em>而页面中的其它部分（比如本样例顶部的图片）的内容，在路由切换时，是不会发生变化的</em></strong></p><blockquote><p>下面是核心文件解析</p></blockquote><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/1.jpg" alt></p><hr><h1 id="3-vue-router配置子路由（嵌套路由、二级路由）"><a href="#3-vue-router配置子路由（嵌套路由、二级路由）" class="headerlink" title="3.vue-router配置子路由（嵌套路由、二级路由）"></a>3.vue-router配置子路由（嵌套路由、二级路由）</h1><p>在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。<br>把Hi.vue改成一个通用(母版)的模板，加入 <strong><em><router-view></router-view></em></strong>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入 <strong><em><router-view></router-view></em></strong>标签。<br><strong><em>然后路由配置如图</em></strong></p><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/2.PNG" alt></p><hr><h1 id="4-使用-JS-代码进行跳转"><a href="#4-使用-JS-代码进行跳转" class="headerlink" title="4.使用 JS 代码进行跳转"></a>4.使用 JS 代码进行跳转</h1><p>除了使用 <strong><em><router-link></router-link></em></strong> 进行跳转外，我们也可以借助如下几个方法在 JavaScript 里进行页面跳转。</p><ul><li><p><strong>1，this.$router.push()</strong></p><pre><code> &lt;template&gt; &lt;div&gt;     &lt;h1&gt;首页&lt;/h1&gt;     &lt;a @click=&quot;handleRouter&quot;&gt;跳转到 hello&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: {     handleRouter() {     this.$router.push(&quot;/hello&quot;);     } } } &lt;/script&gt;</code></pre></li><li><p><strong>2，this.$router.replace()</strong><br>该方法则类似于 <router-link> 的 replace 功能，它不会向 history 添加新记录，而是替换掉当前的 history 记录。</router-link></p><pre><code>  this.$router.replace(&quot;/hello&quot;);</code></pre></li><li><p><strong>3，this.$router.go()</strong><br>该方法类似与 <strong>window.history.go()</strong>，在 history 记录中向前或者后退多少步，参数是整数。</p><pre><code>  //后退1页  this.$router.go(-1);  //前进2页  this.$router.go(2);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 全家桶</title>
      <link href="/2019/09/07/vue-quan-jia-tong/"/>
      <url>/2019/09/07/vue-quan-jia-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建项目架构-技术胖大神"><a href="#搭建项目架构-技术胖大神" class="headerlink" title="搭建项目架构,技术胖大神"></a>搭建项目架构,<strong>技术胖大神</strong></h1><hr><h1 id="Vue本地搭建"><a href="#Vue本地搭建" class="headerlink" title="Vue本地搭建"></a><strong>Vue本地搭建</strong></h1><h1 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a><strong>安装 npm</strong></h1><p>环境安装<br><strong><em>可以在命令行工具里输入</em></strong></p><blockquote><p><strong><em>npm -v</em></strong></p></blockquote><ul><li><p>检测和查询版本</p></li><li><p>下载地址 ：<strong><em><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></em></strong></p></li><li><p>用 npm命令来安装Vue-cli<br>Vue-cli是脚手架工具，作用是用配置好的模板迅速搭建一个项目工程，省去Webpack默认打包配置规则</p></li></ul><p><strong><em>在命令行输入下面命令</em></strong></p><blockquote><p><strong><em>npm install vue-cli -g</em></strong></p></blockquote><ul><li>-g 代表全局安装</li></ul><hr><h1 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a><strong>安装 vue</strong></h1><blockquote><p><strong><em>vue -V</em></strong></p></blockquote><ul><li>用来检测安装版本以及是否安装成功</li></ul><hr><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h1><blockquote><p><strong><em>$ vue init webpack 项目名称</em></strong></p></blockquote><p>(init :初始化项目)</p><ul><li>Project name：项目名称（直接回车则使用括号中默认名字）</li><li>Project description：项目描述（直接点击回车则使用默认名字）</li><li>Author：作者 (如果你有配置git的作者，他会读取。)</li><li>Runtime + Compiler: recommended for most users：运行加编译</li><li>Runtime-only：仅运行时</li><li>Install vue-router?：是否安装 vue-route（这是官方的路由，大多数情况下都使用 Y）</li><li>Use ESLint to lint your code?：是否使用 ESLint 管理代码（ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。)</li><li>Pick an ESLint preset：选择一个 ESLint 预设，编写 vue 项目时的代码风格</li><li>Setup unit tests with Karma + Mocha?：是否安装单元测试 N</li><li>Setup e2e tests with Nightwatch?：是否安装 e2e 测试 N</li></ul><blockquote><p><strong>cd 项目名称</strong></p></blockquote><p>  进入我们的vue项目目录</p><blockquote><p><strong>npm install</strong></p></blockquote><p>NPM通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）</p><ul><li>安装我们的项目依赖包，也就是安装package.json里的包</li><li>1.允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li><li>2.允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>3.允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。  </li></ul><hr><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a><strong>运行项目</strong></h1><blockquote><p><strong>npm run dev</strong></p></blockquote><p>  开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</p><hr><h1 id="打包发布项目"><a href="#打包发布项目" class="headerlink" title="打包发布项目"></a><strong>打包发布项目</strong></h1><blockquote><p><strong>npm run build</strong></p></blockquote><ul><li>在项目开发完成之后，我们可以执行如下命令来进行打包工作。</li><li>打包完成后，项目中会生成 <strong><em>dist</em></strong> 文件夹，我们只需要 <strong><em>dist</em></strong> 文件夹里的内容放到服务器上就行了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 +GitHub 搭建与关联</title>
      <link href="/2019/09/06/2019-conclusion/"/>
      <url>/2019/09/06/2019-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h1 id="搭建Hexo博客-Github"><a href="#搭建Hexo博客-Github" class="headerlink" title="搭建Hexo博客 - Github"></a>搭建Hexo博客 - Github</h1><blockquote><p>搭建Hexo博客 - Github 大体流程：</p><ul><li>1.Hexo本地搭建</li><li>2.Github 搭建</li><li>3.Hexo关联Github 并且通过本地上线到Github</li><li>4.域名与 github 绑定 </li></ul></blockquote><hr><h2 id="1-Hexo-本地搭建，韦阳大神"><a href="#1-Hexo-本地搭建，韦阳大神" class="headerlink" title="1.Hexo 本地搭建，韦阳大神"></a><strong>1.Hexo 本地搭建</strong>，<strong>韦阳大神</strong></h2><p><strong>环境安装</strong><br><strong><em>安装 Node.js </em></strong><br><strong><em>检验是否安装成功 </em></strong></p><blockquote><ul><li><strong>Win + R</strong></li></ul></blockquote><pre><code>node -vnpm -v</code></pre><p> 出现序列号就是安装成功<br><strong><em> 安装 Git </em></strong><br> 输入自己的项目名字，后面加入 <em>.github.io</em> 后缀，然后README 初始化也勾选上，名称一定要和前面的github名字完全一样<br><strong><em> 在设置里面选择主题 </em></strong></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><ul><li><p><strong>本地合适的地方新建一个文件夹</strong><br>在该目录右键点击 <strong><em>Git Bash Here</em></strong> ,打开git的控制窗口，就不用再windows 自带的运行窗口进行了</p></li><li><p><strong>定位到该目录下</strong> 安装Hexo<br>出现报错无视</p><p>  npm i hexo-cli -g</p></li></ul><p>安装完成后输入</p><pre><code>hexo -v</code></pre><p> 检测是否安装完成初始化hexo 文件<br>输入</p><pre><code>hexo init</code></pre><p>初始化文件夹 ，然后安装 </p><pre><code>npm install</code></pre><p>安装必备的组件,完成检测<br>输入</p><pre><code>hexo g</code></pre><p>生成静态文件<br>输入</p><pre><code>hexo s</code></pre><p>  打开本地服务器，出现 <strong><em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em></strong> 则完成安装<br>关闭本地服务器 </p><blockquote><p><strong><em>ctrl +c </em></strong> </p></blockquote><hr><h1 id="2-连接Github与本地"><a href="#2-连接Github与本地" class="headerlink" title="2.连接Github与本地"></a>2.连接Github与本地</h1><p>对着目标文件夹右键 <strong><em>git bash</em></strong>,然后输入下面命令</p><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><p>  生成密匙SSH key</p><pre><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></pre><p>  一直默认回车 在git bash</p><pre><code>cat ~/.ssh/id_rsa.pub </code></pre><p>  将输出内容处置到Github 账号设置里面的SSH key</p><pre><code>ssh -T git@github.com</code></pre><p>  在git bash 输入出现你的用户名等信息就是成功了<br>  在博客根目录的 <strong>_config.yml</strong> 文件配置信息  </p><hr><h1 id="3-本地上传文章，发布文章"><a href="#3-本地上传文章，发布文章" class="headerlink" title="3.本地上传文章，发布文章"></a>3.本地上传文章，发布文章</h1><p>首先在博客根目录右键打开 <strong><em>git bash</em></strong> ,<br>安装一个拓展 </p><pre><code>***npm i hexo-deployer-git***</code></pre><p><strong><em>然后输入</em></strong> </p><pre><code>hexo new post &quot;名称&quot;</code></pre><p>新建一篇文章 <strong><em>\blog\source_posts</em></strong>的目录，可以发现下面多了一个文件夹和一个 <strong><em>.md</em></strong>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦,编写完文件后，根目录下</p><p><strong><em>输入</em></strong> </p><pre><code>hexo g</code></pre><p>生成静态网页，然后<br><strong><em>输入</em></strong> </p><pre><code>hexo s</code></pre><p> 可以本地预览效果，最后<br> <strong><em>输入</em></strong></p><pre><code>hexo d</code></pre><p> 上传到github上。这时打开你的github.io主页就能看到发布的文章啦</p><hr><h1 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4.域名绑定"></a>4.域名绑定</h1><p>//</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax入门和发送http请求</title>
      <link href="/2018/08/24/ajax-ru-men-he-fa-song-http-qing-qiu/"/>
      <url>/2018/08/24/ajax-ru-men-he-fa-song-http-qing-qiu/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a><strong>什么是Ajax</strong></h1><blockquote><p>客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术(Ajax 的核心是 js 对象：XMLHttpRequest。)</p></blockquote><ul><li><p>无刷新数据读取</p><ul><li><p>用户注册/在线聊天室</p></li><li><p>理解同步和异步(基本都用异步请求).</p><p>  <strong>同步: 客户端发起请求–等待–&gt;服务器端处理—等待–&gt;响应–&gt;页面载入 (请求错误时全部重新载入).</strong><br>  同步例子（在银行排队时，只有等到你了，才能够去处理业务。）</p><p>  <strong>异步: 客户端发起请求—&gt;服务器端处理—&gt;响应—&gt;页面载入(填写时,即时更新,部分返回).</strong><br>  异步例子 （在排队的时候，可以玩手机。）</p></li></ul></li></ul><h2 id="发送-Ajax-请求的五个步骤"><a href="#发送-Ajax-请求的五个步骤" class="headerlink" title="发送 Ajax 请求的五个步骤"></a>发送 Ajax 请求的五个步骤</h2><blockquote><p>1.创建异步对象。即 XMLHttpRequest 对象。<br>2.使用open方法设置请求的参数。open(method, url, async)。参数解释：请求的方法、请求的url、是否异步。<br>3.发送请求。<br>4.注册事件。 注册onreadystatechange事件，状态改变时就会调用。<br>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>5.获取返回的数据。</p></blockquote><hr><h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h1><blockquote><p>XMLHttpRequest对象是Ajax中最重要的一个对象。使用Ajax更多的是编写客户端代码，而不是服务端的代码。</p></blockquote><h2 id="1-创建XMLHttpRequest对象"><a href="#1-创建XMLHttpRequest对象" class="headerlink" title="1.创建XMLHttpRequest对象"></a>1.创建XMLHttpRequest对象</h2><p>要创建XMLHttpRequest对象是要分两种情况考虑的：</p><ul><li>在IE6以下的版本</li><li>在IE6以上的版本以及其他内核的浏览器(Mozilla)等</li></ul><pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;        var httpRequest;        if(window.XMLHttpRequest) {            //在IE6以上的版本以及其他内核的浏览器(Mozilla)等            httpRequest = new XMLHttpRequest();        }else if(window.ActiveXObject) {            //在IE6以下的版本            httpRequest = new ActiveXObject();        }    &lt;/script&gt;</code></pre><h2 id="2-了解XMLHttpRequest对象的属性和方法"><a href="#2-了解XMLHttpRequest对象的属性和方法" class="headerlink" title="2.了解XMLHttpRequest对象的属性和方法"></a>2.了解XMLHttpRequest对象的属性和方法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>1.<strong>open()(String method,String url,boolean asynch,</strong>String username,String password)<br>2.<strong>send(content)</strong><br>3.<strong>setRequestHeader(String header,String value)</strong><br>4.getAllResponseHeaders()<br>5.getResponseHeader(String header)<br>6.abort()</p><p><strong>常用的方法就是黑色粗体的前三个</strong></p><ul><li><p><strong>open()：该方法创建http请求</strong></p><ul><li><strong>第一个参数是指定提交方式(post、get)</strong></li><li><strong>第二个参数是指定要提交的地址是哪</strong></li><li><strong>第三个参数是指定是异步还是同步(true表示异步，false表示同步)</strong></li><li>第四(获取所有的响应报头,http认证的时候会用到,是可选的)</li><li>第五(查询响应中的某个字段的值参数在http认证的时候会用到,是可选的)</li></ul></li><li><p><strong>setRequestHeader(String header,String value)：设置消息头（使用post方式才会使用到，get方法并不需要调用该方法）</strong></p><ul><li><strong>xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);</strong></li></ul></li><li><p><strong>send(content)：发送请求给服务器</strong></p><ul><li><strong>如果是get方式，并不需要填写参数，或填写null</strong></li><li><strong>如果是post方式，把要提交的参数写上去</strong></li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><strong>onreadystatechange：请求状态改变的事件触发器（readyState变化时会调用此方法）,一般用于指定回调函数</strong></p><blockquote><p>通过监听onreadystatechange事件,来判断请求的状态.</p></blockquote></li><li><p><strong>readyState：请求状态readyState一改变，回调函数被调用，它有5个状态</strong></p><blockquote><p>readyState属性:响应返回所处状态</p></blockquote><ul><li>0：未初始化(还没有调用open()方法)</li><li>1：open方法成功调用以后(已调用send()方法,正在发送请求)</li><li>2：载入完成,服务器已经应答客户端的请求(send()方法完成,已经收到全部响应 内容)</li><li>3：交互中(解析)。Http头信息已经接收，响应数据尚未接收。(正在解析响应内容)</li><li><strong>4：完成。数据接收完成</strong>(响应内容解析完成,可以在客户端调用了)</li></ul></li></ul><pre><code>//基本完整的一个Ajax请求var request = new XMLHttpRequest();request.open(&quot;GET&quot;,&quot;get.json&quot;,true);request.onreadystatechange = function () {    if (request.readyState === 4) {        if (request.status === 200) {            //响应成功,做一些事情        } else {        //响应失败,做一些事情        }    }};</code></pre><p><img src="//mayanming696.github.io/2018/08/24/ajax-ru-men-he-fa-song-http-qing-qiu/1.png" alt></p><ul><li><strong>responseText：服务器返回的文本内容</strong></li><li><strong>responseXML：服务器返回的兼容DOM的XML内容</strong></li><li><strong>status：服务器返回的状态码</strong></li><li>statusText：服务器返回状态码的文本信息</li></ul><p>回调函数就是<strong>接收服务器返回的内容！</strong></p><p><img src="//mayanming696.github.io/2018/08/24/ajax-ru-men-he-fa-song-http-qing-qiu/2.png" alt></p><hr><h1 id="编写第一个Ajax程序"><a href="#编写第一个Ajax程序" class="headerlink" title="编写第一个Ajax程序"></a>编写第一个Ajax程序</h1><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><ul><li>创建的div只要用于显示服务器返回的数据</li><li>当用户点击按钮的时候，就触发事件。</li></ul><pre><code>    &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;    &lt;input type=&quot;button&quot; onclick=&quot;checkUsername()&quot; value=&quot;检测用户名是否合法&quot;&gt;    &lt;div id=&quot;result&quot;&gt;    &lt;/div&gt;</code></pre><h2 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h2><ul><li>创建XMLHttpRequest对象</li><li>创建http请求</li><li>把文本框的数据发送给http请求的目标</li><li>指定回调函数</li><li>编写回调函数</li><li>发送http请求</li><li>回调函数得到http返回的内容，把内容写在div上</li></ul><pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;        var httpRequest;        function checkUsername() {            if(window.XMLHttpRequest) {                //在IE6以上的版本以及其他内核的浏览器(Mozilla)等                httpRequest = new XMLHttpRequest();            }else if(window.ActiveXObject) {                //在IE6以下的版本                httpRequest = new ActiveXObject();            }            //创建http请求            httpRequest.open(&quot;POST&quot;, &quot;Servlet1&quot;, true);            //因为我使用的是post方式，所以需要设置消息头            httpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);            //指定回调函数            httpRequest.onreadystatechange = response22;            //得到文本框的数据            var name = document.getElementById(&quot;username&quot;).value;            //发送http请求，把要检测的用户名传递进去            httpRequest.send(&quot;username=&quot; + name);        }        function response22() {            //判断请求状态码是否是4【数据接收完成】            if(httpRequest.readyState==4) {                //再判断状态码是否为200【200是成功的】                if(httpRequest.status==200) {                    //得到服务端返回的文本数据                    var text = httpRequest.responseText;                    //把服务端返回的数据写在div上                    var div = document.getElementById(&quot;result&quot;);                    div.innerText = text;                }            }        }    &lt;/script&gt;</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h1 id="XMLHttpRequest解决缓存问题"><a href="#XMLHttpRequest解决缓存问题" class="headerlink" title="XMLHttpRequest解决缓存问题"></a><strong>XMLHttpRequest解决缓存问题</strong></h1><p>在传统的Web中我们也解决过缓存的问题，通过设置response的头信息，返回给浏览器就可以实现不缓存页面了。</p><p>但是呢，现在我们使用XMLHttpRequest，拿到的不是全新的页面，仅仅是服务器端发送过来的数据！！</p><p>那我们要怎么解决缓存的问题呢？？产生缓存的原因就是：我们请求了同一个地址，做了相同的操作。服务端认为我的操作并没有什么变化，就直接把缓存的信息给我了。这样的话，我就不能更换验证码图片了(等等应用)。</p><p>我们可以这样做：</p><ul><li><strong>在每次请求url中加入一个时间戳参数【每次url就不一样了】</strong></li><li>加入时间戳参数到url时，也分两种情况<ul><li><strong>url本身就带有参数了，也就是说有”?”号了，那么添加时间戳的时候就需要用”&amp;”号</strong></li><li><input checked disabled type="checkbox"> url没有参数，直接使用”?”号来添加时间戳</li></ul></li></ul><pre><code>    if(url.indexOf(&quot;?&quot;) &gt;= 0){    url = url + &quot;&amp;t=&quot; + (new Date()).valueOf();    } else{    url = url + &quot;?t=&quot; + (new Date()).valueOf();    }</code></pre><h1 id="XMLHttpRequest跨域访问"><a href="#XMLHttpRequest跨域访问" class="headerlink" title="XMLHttpRequest跨域访问"></a>XMLHttpRequest跨域访问</h1><p><strong>使用XMLHttpRequest去跨域访问是会出现错误的。</strong><br>我们要怎么解决呢？？这时候就要用代理思想了</p><ul><li><strong>XMLHttpRequest先把请求提交给同域的Servlet处理</strong></li><li><strong>同域Servlet再将XMLHttpRequest的请求提交给跨域的服务器</strong></li><li><strong>同域Servlet得到跨域服务器的返回值，再返回给XMLHttpRequest</strong></li></ul><p>这个时候，<strong>XMLHttpRequest跨域访问就分两种(GET和POST)情况了，因为这两种提交数据的方式是不一样的！</strong></p><h2 id="浏览器代码"><a href="#浏览器代码" class="headerlink" title="浏览器代码"></a>浏览器代码</h2><ul><li>我们需要在调用open方法之前判断一下要连接的地址是不是以http开头的，如果是则认为要访问的是跨域的资源</li><li>首先将当前url中的”?”变成”&amp;”，这是因为将要连接的地址改为”Proxy?url=” + url以后，如果原来url地址中有参数的话，新的url地址中就会有两个“?”这会导致服务器端解析参数错误，”url=”之后的内容表示本来要访问的跨域资源的地址。</li></ul><h2 id="GET方式"><a href="#GET方式" class="headerlink" title="GET方式"></a>GET方式</h2><p>GET方式是直接把参数的信息都放在url地址上，所以处理起来会相对简单。</p><p>步骤：</p><ul><li>使用StringBuilder装载着getParameter(“url”)【获取得到地址，呆会要做拼接，所以用StringBuilder】</li><li><em><em>得到其他参数的时候，做URLEncode.encode()，因为我们进入Servlet的时候已经被decode了一次【我们要尽可能保留原始请求】(参照解决中文乱码) </em></em></li><li>遍历所有的请求参数，只要名字不是”url”，就添加到StringBuilder中【第一个参数为”?”,其他的参数为”&amp;”】(<a href="http://localhost:8080/url?aa=bb&amp;cc=dd" target="_blank" rel="noopener">http://localhost:8080/url?aa=bb&amp;cc=dd</a>)</li><li>创建URL对象，把拼接成的StringBuilder传递进去</li><li>使用BufferReader读取远程服务器返回的数据，要指定输入流编码格式，否则会乱码</li></ul><pre><code>        BufferedReader reader = new BufferedReader(new InputStreamReader(URL对象.openSteam(),&quot;UTF-8&quot;));</code></pre><ul><li>最后，把远程服务器读取到的数据再返回给XMLHttpRequest</li></ul><h2 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式"></a>POST方式</h2><p>POST方式把参数的信息都封装到HTTP请求中，在URL进行连接的时候，需要把数据写给远程服务器</p><p>步骤：</p><ul><li>得到url参数，创建StringBuilder</li><li><em><em>得到其他参数的时候，做URLEncode.encode()，因为我们进入Servlet的时候已经被decode了一次【我们要尽可能保留原始请求】(参照解决中文乱码) </em></em></li><li>遍历所有的请求参数，只要名字不是”url”，就添加到StringBuilder中【第一个参数直接给出,其他的参数为”&amp;”】(aa=bb&amp;cc=dd&amp;ee=ff)</li><li>创建URL对象，创建URL连接器，允许写数据到远程服务器上</li></ul><pre><code>    URL url = new URL(url);    URLConnection connection = url.openConnection;    connection.setDoOutPut(true);</code></pre><ul><li>得到写数据流</li></ul><pre><code>OutputSteamWriter writer = new OutputSteamWriter(conncetion.getOutputSteam)</code></pre><ul><li>把StringBuilder的数据写到远程服务器上，并flush</li><li>使用BufferReader读取远程服务器返回的数据</li></ul><pre><code>BufferedReader reader =  new BufferedReader(new InputSteamReader(conncetion.inputSteamReader,&quot;UTF-8&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
