<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue-router参数传递</title>
      <link href="/2019/09/10/vue-router-can-shu-chuan-di/"/>
      <url>/2019/09/10/vue-router-can-shu-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="一、使用冒号（-）的形式传递参数-URL传递参数"><a href="#一、使用冒号（-）的形式传递参数-URL传递参数" class="headerlink" title="一、使用冒号（:）的形式传递参数(URL传递参数)"></a><strong>一、使用冒号（:）的形式传递参数(URL传递参数)</strong></h1><blockquote><p><strong>1，路由列表的参数设置</strong></p></blockquote><p>（1）路由列表的 path 是可以带参数的，我们在路由配置文件（router/index.js）里以冒号的形式设置参数。<br>（2）下面样例代码中，我在跳转到欢迎页面（/hello）时，带有两个参数 : <strong>id</strong> 和 <strong>userName</strong>。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/1.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link to=&quot;/hello/123/hangge&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push(&quot;/hello/123/hangge&quot;);</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;&lt;div&gt;    &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;    &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数成功传递并显示。</p><hr><h1 id="二、使用-query-方式传递参数-to传递，参数显示URL"><a href="#二、使用-query-方式传递参数-to传递，参数显示URL" class="headerlink" title="二、使用 query 方式传递参数(to传递，参数显示URL)"></a><strong>二、使用 query 方式传递参数(to传递，参数显示URL)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>query 方式类似 get 传参，即通过 URL 传递参数。而路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/2.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{path:&#39;/hello&#39;, query:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    path:&#39;/hello&#39;,    query:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.query.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.query.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.query.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数是自动拼接到 url 后面进行传递的。</p><hr><h1 id="三、使用-params-方式传递参数-to传递，参数不显示URL-推荐"><a href="#三、使用-params-方式传递参数-to传递，参数不显示URL-推荐" class="headerlink" title="三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)"></a><strong>三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>params 方式类似于 post 传参，即传递的参数不会显示在 URL 上。同上面的 query 方式一样，路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/3.png" alt></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p> <strong>注意：params 只能用 name 来引入路由，而不能用 path。</strong><br> （1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{name:&#39;hello&#39;, params:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    name:&#39;hello&#39;,    params:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到这种方式，参数的传递不会拼接到 url 后面。</p><hr><h1 id="附：使用-props-实现参数解耦"><a href="#附：使用-props-实现参数解耦" class="headerlink" title="附：使用 props 实现参数解耦"></a>附：使用 props 实现参数解耦</h1><p> 从上面的样例可以看出，当路由携带参数跳转时，页面这边通过 <strong><em>$route.params.xxx</em></strong> 或 <strong><em>$route.query.xxx</em></strong> 来获取传递过来的数据。但这样有个问题，由于组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。<br>    要解决这个问题，我们可以使用 props 将组件和路由解耦。props 共有如下三种模式。</p><blockquote><p><strong>1，布尔模式</strong></p></blockquote><p>（1）直接将路由配置中的 props 属性被设置为 true，那么参数将会被设置为组件属性。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/4.png" alt></p><p>（2）然后我们页面组件这边不再需要通过 $route.params.xxx 或 $route.query.xxx 来获取传递过来的数据。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/5.png" alt></p><blockquote><p><strong>2，对象模式</strong></p></blockquote><p>（1）我们可以将 props 设置为一个对象，对象内容会被设置为组件属性。这种方式常用来配置静态参数。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/6.png" alt></p><p>（2）然后页面组件这边获取数据方式和前面一样。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/7.png" alt></p><blockquote><p><strong>3，函数模式</strong></p></blockquote><p>（1）我们还可以创建一个函数返回 props，在函数中对参数值进行处理，或者将静态值与基于路由的值结合。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/8.png" alt></p><p>（2）这里假设我们使用 JS 进行跳转，代码如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/9.png" alt></p><p>（3）目标页面组件代码，以及运行结果如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/10.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router路由详解</title>
      <link href="/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/"/>
      <url>/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>基本介绍</em></p></blockquote><hr><h1 id="什么是-vue-router"><a href="#什么是-vue-router" class="headerlink" title="什么是 vue-router?"></a><strong>什么是 vue-router?</strong></h1><p> (1)<strong><em>vue-router</em></strong> 是Vue官方提供前端路由插件包，借助它我们实现可以基于路由和组件的单页面应用，路径管理器<br> (2)它与传统的页面区别在于：</p><ul><li>传统的页面应用采用的是后端路由，即通过超链接来实现页面切换和跳转的。</li><li>而在 <strong><em>vue-router</em></strong> 单页面应用中，则是通过路径之间的切换（实际上就是组件的切换）。</li></ul><hr><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a><strong>安装配置</strong></h1><p> (1)如果我们使用 <strong><em>vue-cli</em></strong> 脚手架来搭建项目，在开始配置过程会选择是否需要安装路由，具体参考我之前的这篇文章：</p><ul><li><a href="/2019/09/07/vue-quan-jia-tong/">Vue.js - 使用vue-cli搭建项目（附：详细操作步骤）</a></li></ul><p>(2)如果项目搭建时没有安装也没关系，可以执行如下命令手动安装：</p><pre><code>npm install vue-router</code></pre><hr><blockquote><p><strong>路由分类</strong></p></blockquote><h1 id="1-router-link-制作导航"><a href="#1-router-link-制作导航" class="headerlink" title="1.router-link 制作导航"></a>1.router-link 制作导航</h1><ul><li><p>router-link 是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址,当然也可以使用 v-bind 来动态设置</p></li><li><p>使用 <strong><em> <router-link></router-link></em></strong>，在 HTML5 的 History 模式下会拦截点击，避免浏览器重新加载页面。</p></li><li><p>注意：被选中的router-link将自动添加一个class属性值 <strong><em>.router-link-active</em></strong></p><pre><code>  &lt;router-link to=&quot;/&quot;&gt;[text]&lt;/router-link&gt;</code></pre></li><li><p>除了 to 属性外，<router-link> 还有一些其他常用的 prop：</router-link></p><ul><li><p><strong>tag</strong> 可以指定渲染成什么标签。比如下面渲染的结果就是 <strong><em>li</em></strong> 而不是 <strong><em>a</em></strong></p><pre><code>&lt;router-link to=&quot;/hello&quot; tag=&quot;li&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p><strong>replace</strong> 配置后不会留下 History 记录，即导航后不能用后退键返回上一个页面。</p><pre><code>&lt;router-link to=&quot;/hello&quot; replace&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p>active-class</p><ul><li>当 <router-link> 对应的路由匹配成功时，会自动给当前元素设置一个名为 router-link-active 的 class。我们通常会利用它来高亮显示当前页面对应的导航菜单项。</router-link></li><li>而通过设置 active-class 可以修改默认的 class 样式名称（router-link-active），不过一般情况下我们也不需要改它，使用默认就好了。                   </li></ul></li></ul></li><li><p>to：导航路径，要填写的是你在router/index.js文件里配置的path值，<br>如果要导航到默认首页，只需要写成 to=”/“ ，</p></li><li><p>[text] ：就是我们要显示给用户的导航名称。</p></li></ul><hr><h1 id="2-router-view-用于渲染匹配到的组件"><a href="#2-router-view-用于渲染匹配到的组件" class="headerlink" title="2.router-view 用于渲染匹配到的组件"></a>2.router-view 用于渲染匹配到的组件</h1><p>会根据当前路由动态渲染不同的页面组件<br>用Vue-cli脚手架创建了项目结构，<strong><em>src文件目录下会有一个router文件夹</em></strong>,编写路由组件的地方在<br> <strong><em>编写路由组件的地方</em></strong><br><strong><em>路由的核心文件:src/router/index.js</em></strong><br> <strong><em>运行网页时，<router-view> 会根据当前路由动态渲染不同的页面组件</router-view></em></strong><br> <strong><em>而页面中的其它部分（比如本样例顶部的图片）的内容，在路由切换时，是不会发生变化的</em></strong></p><blockquote><p>下面是核心文件解析</p></blockquote><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/1.jpg" alt></p><hr><h1 id="3-vue-router配置子路由（嵌套路由、二级路由）"><a href="#3-vue-router配置子路由（嵌套路由、二级路由）" class="headerlink" title="3.vue-router配置子路由（嵌套路由、二级路由）"></a>3.vue-router配置子路由（嵌套路由、二级路由）</h1><p>在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。<br>把Hi.vue改成一个通用(母版)的模板，加入 <strong><em><router-view></router-view></em></strong>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入 <strong><em><router-view></router-view></em></strong>标签。<br><strong><em>然后路由配置如图</em></strong></p><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/2.PNG" alt></p><hr><h1 id="4-使用-JS-代码进行跳转"><a href="#4-使用-JS-代码进行跳转" class="headerlink" title="4.使用 JS 代码进行跳转"></a>4.使用 JS 代码进行跳转</h1><p>除了使用 <strong><em><router-link></router-link></em></strong> 进行跳转外，我们也可以借助如下几个方法在 JavaScript 里进行页面跳转。</p><ul><li><p><strong>1，this.$router.push()</strong></p><pre><code> &lt;template&gt; &lt;div&gt;     &lt;h1&gt;首页&lt;/h1&gt;     &lt;a @click=&quot;handleRouter&quot;&gt;跳转到 hello&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: {     handleRouter() {     this.$router.push(&quot;/hello&quot;);     } } } &lt;/script&gt;</code></pre></li><li><p><strong>2，this.$router.replace()</strong><br>该方法则类似于 <router-link> 的 replace 功能，它不会向 history 添加新记录，而是替换掉当前的 history 记录。</router-link></p><pre><code>  this.$router.replace(&quot;/hello&quot;);</code></pre></li><li><p><strong>3，this.$router.go()</strong><br>该方法类似与 <strong>window.history.go()</strong>，在 history 记录中向前或者后退多少步，参数是整数。</p><pre><code>  //后退1页  this.$router.go(-1);  //前进2页  this.$router.go(2);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 全家桶</title>
      <link href="/2019/09/07/vue-quan-jia-tong/"/>
      <url>/2019/09/07/vue-quan-jia-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建项目架构-技术胖大神"><a href="#搭建项目架构-技术胖大神" class="headerlink" title="搭建项目架构,技术胖大神"></a>搭建项目架构,<strong>技术胖大神</strong></h1><hr><h1 id="Vue本地搭建"><a href="#Vue本地搭建" class="headerlink" title="Vue本地搭建"></a><strong>Vue本地搭建</strong></h1><h1 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a><strong>安装 npm</strong></h1><p>环境安装<br><strong><em>可以在命令行工具里输入</em></strong></p><blockquote><p><strong><em>npm -v</em></strong></p></blockquote><ul><li><p>检测和查询版本</p></li><li><p>下载地址 ：<strong><em><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></em></strong></p></li><li><p>用 npm命令来安装Vue-cli<br>Vue-cli是脚手架工具，作用是用配置好的模板迅速搭建一个项目工程，省去Webpack默认打包配置规则</p></li></ul><p><strong><em>在命令行输入下面命令</em></strong></p><blockquote><p><strong><em>npm install vue-cli -g</em></strong></p></blockquote><ul><li>-g 代表全局安装</li></ul><hr><h1 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a><strong>安装 vue</strong></h1><blockquote><p><strong><em>vue -V</em></strong></p></blockquote><ul><li>用来检测安装版本以及是否安装成功</li></ul><hr><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h1><blockquote><p><strong><em>$ vue init webpack 项目名称</em></strong></p></blockquote><p>(init :初始化项目)</p><ul><li>Project name：项目名称（直接回车则使用括号中默认名字）</li><li>Project description：项目描述（直接点击回车则使用默认名字）</li><li>Author：作者 (如果你有配置git的作者，他会读取。)</li><li>Runtime + Compiler: recommended for most users：运行加编译</li><li>Runtime-only：仅运行时</li><li>Install vue-router?：是否安装 vue-route（这是官方的路由，大多数情况下都使用 Y）</li><li>Use ESLint to lint your code?：是否使用 ESLint 管理代码（ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。)</li><li>Pick an ESLint preset：选择一个 ESLint 预设，编写 vue 项目时的代码风格</li><li>Setup unit tests with Karma + Mocha?：是否安装单元测试 N</li><li>Setup e2e tests with Nightwatch?：是否安装 e2e 测试 N</li></ul><blockquote><p><strong>cd 项目名称</strong></p></blockquote><p>  进入我们的vue项目目录</p><blockquote><p><strong>npm install</strong></p></blockquote><p>NPM通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）</p><ul><li>安装我们的项目依赖包，也就是安装package.json里的包</li><li>1.允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li><li>2.允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>3.允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。  </li></ul><hr><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a><strong>运行项目</strong></h1><blockquote><p><strong>npm run dev</strong></p></blockquote><p>  开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</p><hr><h1 id="打包发布项目"><a href="#打包发布项目" class="headerlink" title="打包发布项目"></a><strong>打包发布项目</strong></h1><blockquote><p><strong>npm run build</strong></p></blockquote><ul><li>在项目开发完成之后，我们可以执行如下命令来进行打包工作。</li><li>打包完成后，项目中会生成 <strong><em>dist</em></strong> 文件夹，我们只需要 <strong><em>dist</em></strong> 文件夹里的内容放到服务器上就行了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 +GitHub 搭建与关联</title>
      <link href="/2019/09/06/2019-conclusion/"/>
      <url>/2019/09/06/2019-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h1 id="搭建Hexo博客-Github"><a href="#搭建Hexo博客-Github" class="headerlink" title="搭建Hexo博客 - Github"></a>搭建Hexo博客 - Github</h1><blockquote><p>搭建Hexo博客 - Github 大体流程：</p><ul><li>1.Hexo本地搭建</li><li>2.Github 搭建</li><li>3.Hexo关联Github 并且通过本地上线到Github</li><li>4.域名与 github 绑定 </li></ul></blockquote><hr><h2 id="1-Hexo-本地搭建，韦阳大神"><a href="#1-Hexo-本地搭建，韦阳大神" class="headerlink" title="1.Hexo 本地搭建，韦阳大神"></a><strong>1.Hexo 本地搭建</strong>，<strong>韦阳大神</strong></h2><p><strong>环境安装</strong><br><strong><em>安装 Node.js </em></strong><br><strong><em>检验是否安装成功 </em></strong></p><blockquote><ul><li><strong>Win + R</strong></li></ul></blockquote><pre><code>node -vnpm -v</code></pre><p> 出现序列号就是安装成功<br><strong><em> 安装 Git </em></strong><br> 输入自己的项目名字，后面加入 <em>.github.io</em> 后缀，然后README 初始化也勾选上，名称一定要和前面的github名字完全一样<br><strong><em> 在设置里面选择主题 </em></strong></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><ul><li><p><strong>本地合适的地方新建一个文件夹</strong><br>在该目录右键点击 <strong><em>Git Bash Here</em></strong> ,打开git的控制窗口，就不用再windows 自带的运行窗口进行了</p></li><li><p><strong>定位到该目录下</strong> 安装Hexo<br>出现报错无视</p><p>  npm i hexo-cli -g</p></li></ul><p>安装完成后输入</p><pre><code>hexo -v</code></pre><p> 检测是否安装完成初始化hexo 文件<br>输入</p><pre><code>hexo init</code></pre><p>初始化文件夹 ，然后安装 </p><pre><code>npm install</code></pre><p>安装必备的组件,完成检测<br>输入</p><pre><code>hexo g</code></pre><p>生成静态文件<br>输入</p><pre><code>hexo s</code></pre><p>  打开本地服务器，出现 <strong><em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em></strong> 则完成安装<br>关闭本地服务器 </p><blockquote><p><strong><em>ctrl +c </em></strong> </p></blockquote><hr><h1 id="2-连接Github与本地"><a href="#2-连接Github与本地" class="headerlink" title="2.连接Github与本地"></a>2.连接Github与本地</h1><p>对着目标文件夹右键 <strong><em>git bash</em></strong>,然后输入下面命令</p><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><p>  生成密匙SSH key</p><pre><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></pre><p>  一直默认回车 在git bash</p><pre><code>cat ~/.ssh/id_rsa.pub </code></pre><p>  将输出内容处置到Github 账号设置里面的SSH key</p><pre><code>ssh -T git@github.com</code></pre><p>  在git bash 输入出现你的用户名等信息就是成功了<br>  在博客根目录的 <strong>_config.yml</strong> 文件配置信息  </p><hr><h1 id="3-本地上传文章，发布文章"><a href="#3-本地上传文章，发布文章" class="headerlink" title="3.本地上传文章，发布文章"></a>3.本地上传文章，发布文章</h1><p>首先在博客根目录右键打开 <strong><em>git bash</em></strong> ,<br>安装一个拓展 </p><pre><code>***npm i hexo-deployer-git***</code></pre><p><strong><em>然后输入</em></strong> </p><pre><code>hexo new post &quot;名称&quot;</code></pre><p>新建一篇文章 <strong><em>\blog\source_posts</em></strong>的目录，可以发现下面多了一个文件夹和一个 <strong><em>.md</em></strong>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦,编写完文件后，根目录下</p><p><strong><em>输入</em></strong> </p><pre><code>hexo g</code></pre><p>生成静态网页，然后<br><strong><em>输入</em></strong> </p><pre><code>hexo s</code></pre><p> 可以本地预览效果，最后<br> <strong><em>输入</em></strong></p><pre><code>hexo d</code></pre><p> 上传到github上。这时打开你的github.io主页就能看到发布的文章啦</p><hr><h1 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4.域名绑定"></a>4.域名绑定</h1><p>//</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax入门</title>
      <link href="/2018/09/27/ajax-ru-men/"/>
      <url>/2018/09/27/ajax-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a><strong>什么是Ajax</strong></h1><blockquote><p>客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术(Ajax 的核心是 js 对象：XMLHttpRequest。)</p></blockquote><ul><li><p>无刷新数据读取</p><ul><li><p>用户注册/在线聊天室</p></li><li><p>理解同步和异步(基本都用异步请求).</p><p>  <strong>同步: 客户端发起请求–等待–&gt;服务器端处理—等待–&gt;响应–&gt;页面载入 (请求错误时全部重新载入).</strong><br>  同步例子（在银行排队时，只有等到你了，才能够去处理业务。）</p><p>  <strong>异步: 客户端发起请求—&gt;服务器端处理—&gt;响应—&gt;页面载入(填写时,即时更新,部分返回).</strong><br>  异步例子 （在排队的时候，可以玩手机。）</p></li></ul></li></ul><h2 id="发送-Ajax-请求的五个步骤"><a href="#发送-Ajax-请求的五个步骤" class="headerlink" title="发送 Ajax 请求的五个步骤"></a>发送 Ajax 请求的五个步骤</h2><blockquote><p>1.创建异步对象。即 XMLHttpRequest 对象。<br>2.使用open方法设置请求的参数。open(method, url, async)。参数解释：请求的方法、请求的url、是否异步。<br>3.发送请求。<br>4.注册事件。 注册onreadystatechange事件，状态改变时就会调用。<br>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>5.获取返回的数据。</p></blockquote><hr><h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h1><blockquote><p>XMLHttpRequest对象是Ajax中最重要的一个对象。使用Ajax更多的是编写客户端代码，而不是服务端的代码。</p></blockquote><h2 id="1-创建XMLHttpRequest对象"><a href="#1-创建XMLHttpRequest对象" class="headerlink" title="1.创建XMLHttpRequest对象"></a>1.创建XMLHttpRequest对象</h2><p>要创建XMLHttpRequest对象是要分两种情况考虑的：</p><ul><li>在IE6以下的版本</li><li>在IE6以上的版本以及其他内核的浏览器(Mozilla)等</li></ul><pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;        var httpRequest;        if(window.XMLHttpRequest) {            //在IE6以上的版本以及其他内核的浏览器(Mozilla)等            httpRequest = new XMLHttpRequest();        }else if(window.ActiveXObject) {            //在IE6以下的版本            httpRequest = new ActiveXObject();        }    &lt;/script&gt;</code></pre><h2 id="2-了解XMLHttpRequest对象的属性和方法"><a href="#2-了解XMLHttpRequest对象的属性和方法" class="headerlink" title="2.了解XMLHttpRequest对象的属性和方法"></a>2.了解XMLHttpRequest对象的属性和方法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>1.<strong>open()(String method,String url,boolean asynch,</strong>String username,String password)<br>2.<strong>send(content)</strong><br>3.<strong>setRequestHeader(String header,String value)</strong><br>4.getAllResponseHeaders()<br>5.getResponseHeader(String header)<br>6.abort()</p><p><strong>常用的方法就是黑色粗体的前三个</strong></p><ul><li><p><strong>open()：该方法创建http请求</strong></p><ul><li><strong>第一个参数是指定提交方式(post、get)</strong></li><li><strong>第二个参数是指定要提交的地址是哪</strong></li><li><strong>第三个参数是指定是异步还是同步(true表示异步，false表示同步)</strong></li><li>第四(获取所有的响应报头,http认证的时候会用到,是可选的)</li><li>第五(查询响应中的某个字段的值参数在http认证的时候会用到,是可选的)</li></ul></li><li><p><strong>setRequestHeader(String header,String value)：设置消息头（使用post方式才会使用到，get方法并不需要调用该方法）</strong></p><ul><li><strong>xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);</strong></li></ul></li><li><p><strong>send(content)：发送请求给服务器</strong></p><ul><li><strong>如果是get方式，并不需要填写参数，或填写null</strong></li><li><strong>如果是post方式，把要提交的参数写上去</strong></li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><strong>onreadystatechange：请求状态改变的事件触发器（readyState变化时会调用此方法）,一般用于指定回调函数</strong></p><blockquote><p>通过监听onreadystatechange事件,来判断请求的状态.</p></blockquote></li><li><p><strong>readyState：请求状态readyState一改变，回调函数被调用，它有5个状态</strong></p><blockquote><p>readyState属性:响应返回所处状态</p></blockquote><ul><li>0：未初始化(还没有调用open()方法)</li><li>1：open方法成功调用以后(已调用send()方法,正在发送请求)</li><li>2：载入完成,服务器已经应答客户端的请求(send()方法完成,已经收到全部响应 内容)</li><li>3：交互中(解析)。Http头信息已经接收，响应数据尚未接收。(正在解析响应内容)</li><li><strong>4：完成。数据接收完成</strong>(响应内容解析完成,可以在客户端调用了)</li></ul></li></ul><pre><code>//基本完整的一个Ajax请求var request = new XMLHttpRequest();request.open(&quot;GET&quot;,&quot;get.json&quot;,true);request.onreadystatechange = function () {    if (request.readyState === 4) {        if (request.status === 200) {            //响应成功,做一些事情        } else {        //响应失败,做一些事情        }    }};</code></pre><p><img src="//mayanming696.github.io/2018/09/27/ajax-ru-men/1.png" alt></p><ul><li><strong>responseText：服务器返回的文本内容</strong></li><li><strong>responseXML：服务器返回的兼容DOM的XML内容</strong></li><li><strong>status：服务器返回的状态码</strong></li><li>statusText：服务器返回状态码的文本信息</li></ul><p>回调函数就是<strong>接收服务器返回的内容！</strong></p><p><img src="//mayanming696.github.io/2018/09/27/ajax-ru-men/2.png" alt></p><hr><h1 id="编写第一个Ajax程序"><a href="#编写第一个Ajax程序" class="headerlink" title="编写第一个Ajax程序"></a>编写第一个Ajax程序</h1><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><ul><li>创建的div只要用于显示服务器返回的数据</li><li>当用户点击按钮的时候，就触发事件。</li></ul><pre><code>    &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;    &lt;input type=&quot;button&quot; onclick=&quot;checkUsername()&quot; value=&quot;检测用户名是否合法&quot;&gt;    &lt;div id=&quot;result&quot;&gt;    &lt;/div&gt;</code></pre><h2 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h2><ul><li>创建XMLHttpRequest对象</li><li>创建http请求</li><li>把文本框的数据发送给http请求的目标</li><li>指定回调函数</li><li>编写回调函数</li><li>发送http请求</li><li>回调函数得到http返回的内容，把内容写在div上</li></ul><pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;        var httpRequest;        function checkUsername() {            if(window.XMLHttpRequest) {                //在IE6以上的版本以及其他内核的浏览器(Mozilla)等                httpRequest = new XMLHttpRequest();            }else if(window.ActiveXObject) {                //在IE6以下的版本                httpRequest = new ActiveXObject();            }            //创建http请求            httpRequest.open(&quot;POST&quot;, &quot;Servlet1&quot;, true);            //因为我使用的是post方式，所以需要设置消息头            httpRequest.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);            //指定回调函数            httpRequest.onreadystatechange = response22;            //得到文本框的数据            var name = document.getElementById(&quot;username&quot;).value;            //发送http请求，把要检测的用户名传递进去            httpRequest.send(&quot;username=&quot; + name);        }        function response22() {            //判断请求状态码是否是4【数据接收完成】            if(httpRequest.readyState==4) {                //再判断状态码是否为200【200是成功的】                if(httpRequest.status==200) {                    //得到服务端返回的文本数据                    var text = httpRequest.responseText;                    //把服务端返回的数据写在div上                    var div = document.getElementById(&quot;result&quot;);                    div.innerText = text;                }            }        }    &lt;/script&gt;</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h1 id="XMLHttpRequest解决缓存问题"><a href="#XMLHttpRequest解决缓存问题" class="headerlink" title="XMLHttpRequest解决缓存问题"></a><strong>XMLHttpRequest解决缓存问题</strong></h1><p>在传统的Web中我们也解决过缓存的问题，通过设置response的头信息，返回给浏览器就可以实现不缓存页面了。</p><p>但是呢，现在我们使用XMLHttpRequest，拿到的不是全新的页面，仅仅是服务器端发送过来的数据！！</p><p>那我们要怎么解决缓存的问题呢？？产生缓存的原因就是：我们请求了同一个地址，做了相同的操作。服务端认为我的操作并没有什么变化，就直接把缓存的信息给我了。这样的话，我就不能更换验证码图片了(等等应用)。</p><p>我们可以这样做：</p><ul><li><strong>在每次请求url中加入一个时间戳参数【每次url就不一样了】</strong></li><li>加入时间戳参数到url时，也分两种情况<ul><li><strong>url本身就带有参数了，也就是说有”?”号了，那么添加时间戳的时候就需要用”&amp;”号</strong></li><li><input checked disabled type="checkbox"> url没有参数，直接使用”?”号来添加时间戳</li></ul></li></ul><pre><code>    if(url.indexOf(&quot;?&quot;) &gt;= 0){    url = url + &quot;&amp;t=&quot; + (new Date()).valueOf();    } else{    url = url + &quot;?t=&quot; + (new Date()).valueOf();    }</code></pre><h1 id="XMLHttpRequest跨域访问"><a href="#XMLHttpRequest跨域访问" class="headerlink" title="XMLHttpRequest跨域访问"></a>XMLHttpRequest跨域访问</h1><p><strong>使用XMLHttpRequest去跨域访问是会出现错误的。</strong><br>我们要怎么解决呢？？这时候就要用代理思想了</p><ul><li><strong>XMLHttpRequest先把请求提交给同域的Servlet处理</strong></li><li><strong>同域Servlet再将XMLHttpRequest的请求提交给跨域的服务器</strong></li><li><strong>同域Servlet得到跨域服务器的返回值，再返回给XMLHttpRequest</strong></li></ul><p>这个时候，<strong>XMLHttpRequest跨域访问就分两种(GET和POST)情况了，因为这两种提交数据的方式是不一样的！</strong></p><h2 id="浏览器代码"><a href="#浏览器代码" class="headerlink" title="浏览器代码"></a>浏览器代码</h2><ul><li>我们需要在调用open方法之前判断一下要连接的地址是不是以http开头的，如果是则认为要访问的是跨域的资源</li><li>首先将当前url中的”?”变成”&amp;”，这是因为将要连接的地址改为”Proxy?url=” + url以后，如果原来url地址中有参数的话，新的url地址中就会有两个“?”这会导致服务器端解析参数错误，”url=”之后的内容表示本来要访问的跨域资源的地址。</li></ul><h2 id="GET方式"><a href="#GET方式" class="headerlink" title="GET方式"></a>GET方式</h2><p>GET方式是直接把参数的信息都放在url地址上，所以处理起来会相对简单。</p><p>步骤：</p><ul><li>使用StringBuilder装载着getParameter(“url”)【获取得到地址，呆会要做拼接，所以用StringBuilder】</li><li><em><em>得到其他参数的时候，做URLEncode.encode()，因为我们进入Servlet的时候已经被decode了一次【我们要尽可能保留原始请求】(参照解决中文乱码) </em></em></li><li>遍历所有的请求参数，只要名字不是”url”，就添加到StringBuilder中【第一个参数为”?”,其他的参数为”&amp;”】(<a href="http://localhost:8080/url?aa=bb&amp;cc=dd" target="_blank" rel="noopener">http://localhost:8080/url?aa=bb&amp;cc=dd</a>)</li><li>创建URL对象，把拼接成的StringBuilder传递进去</li><li>使用BufferReader读取远程服务器返回的数据，要指定输入流编码格式，否则会乱码</li></ul><pre><code>        BufferedReader reader = new BufferedReader(new InputStreamReader(URL对象.openSteam(),&quot;UTF-8&quot;));</code></pre><ul><li>最后，把远程服务器读取到的数据再返回给XMLHttpRequest</li></ul><h2 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式"></a>POST方式</h2><p>POST方式把参数的信息都封装到HTTP请求中，在URL进行连接的时候，需要把数据写给远程服务器</p><p>步骤：</p><ul><li>得到url参数，创建StringBuilder</li><li><em><em>得到其他参数的时候，做URLEncode.encode()，因为我们进入Servlet的时候已经被decode了一次【我们要尽可能保留原始请求】(参照解决中文乱码) </em></em></li><li>遍历所有的请求参数，只要名字不是”url”，就添加到StringBuilder中【第一个参数直接给出,其他的参数为”&amp;”】(aa=bb&amp;cc=dd&amp;ee=ff)</li><li>创建URL对象，创建URL连接器，允许写数据到远程服务器上</li></ul><pre><code>    URL url = new URL(url);    URLConnection connection = url.openConnection;    connection.setDoOutPut(true);</code></pre><ul><li>得到写数据流</li></ul><pre><code>OutputSteamWriter writer = new OutputSteamWriter(conncetion.getOutputSteam)</code></pre><ul><li>把StringBuilder的数据写到远程服务器上，并flush</li><li>使用BufferReader读取远程服务器返回的数据</li></ul><pre><code>BufferedReader reader =  new BufferedReader(new InputSteamReader(conncetion.inputSteamReader,&quot;UTF-8&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面性能优化</title>
      <link href="/2018/09/26/ye-mian-xing-neng-you-hua/"/>
      <url>/2018/09/26/ye-mian-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<p><strong>前言页面性能优化</strong></p><blockquote><p>提升页面性能优化的方法有哪些：</p></blockquote><ul><li>1.资源压缩合并，减少http请求</li><li>2.非核心代码异步加载 –&gt; 异步加载的方式 –&gt; 异步加载的区别</li><li>3.利用浏览器缓存 –&gt; 缓存的分类 –&gt; 缓存的原理(缓存是所有性能优化的方式中最重要的一步)<br>有的人可能会回答local storage 和session storage，其实不是这个。浏览器缓存和存储不是一回事。</li><li>4.使用CDN <strong>(浏览器第一次打开页面时，缓存是起不了作用的)</strong></li><li>5.DNS预解析</li></ul><hr><h1 id="一、资源压缩合并，减少http请求"><a href="#一、资源压缩合并，减少http请求" class="headerlink" title="一、资源压缩合并，减少http请求"></a>一、资源压缩合并，减少http请求</h1><ul><li>合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩</li><li>图片较多的页面也可以使用 lazyLoad 等技术进行优化。</li><li>精灵图、svg图等</li></ul><hr><h1 id="二、非核心代码异步加载"><a href="#二、非核心代码异步加载" class="headerlink" title="二、非核心代码异步加载"></a>二、非核心代码异步加载</h1><p>异步加载的方式：（这里不说框架，只说原理）</p><ul><li>动态脚本加载</li><li>defer</li><li>async</li></ul><h2 id="动态脚本加载"><a href="#动态脚本加载" class="headerlink" title="动态脚本加载"></a><strong>动态脚本加载</strong></h2><p>使用document.createElement创建一个script标签，即document.createElement(‘script’)，在需要的时候调用。</p><pre><code>&lt;script&gt;document.createElement(&quot;&lt;script src=&#39;a.js&#39;&gt;&lt;\/script&gt;&quot;);&lt;/script&gt;</code></pre><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>通过异步的方式加载defer1.js文件：</p><pre><code>&lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;</code></pre><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><blockquote><p>HTmL5新增特性。</p></blockquote><p>通过异步的方式加载async1.js文件：</p><pre><code>&lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt;</code></pre><p>defer和async的区别</p><ul><li>defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。</li><li>async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。</li></ul><hr><h1 id="三、利用浏览器缓存"><a href="#三、利用浏览器缓存" class="headerlink" title="三、利用浏览器缓存"></a>三、利用浏览器缓存</h1><p>浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<br>缓存：资源文件（比如图片）在本地的硬盘里存有副本，浏览器下次请求的时候，可能直接从本地磁盘里读取，而不会重新请求图片的url。</p><p><strong>浏览器缓存基本认识</strong></p><ul><li><p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；<br>缓存分为：</p></li><li><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p></li><li><p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p></li><li><p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p></li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存原理：当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：</p><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/1.png" alt></p><p>强缓存是利用 http 响应头中的<strong>Expires(较老的强缓存管理)或Cache-Control(管理更有效，安全)</strong>实现的。它们都用来表示资源在客户端缓存的有效期。</p><ul><li>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/2.png" alt></p><ul><li><p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）</p></li><li><p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p></li><li><p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p></li></ul><blockquote><p><strong>注意：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-Control同时存在时，Cache-Control的优先级高于Expires。</strong></p></blockquote><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/3.png" alt></p><p>下面讲一下二者的区别。</p><ul><li>1、Expires：服务器返回的绝对时间。</li></ul><p>是较老的强缓存管理 response header。浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires的时间之前，就能命中缓存，否则就不行。</p><p>如果缓存没有命中，浏览器直接从服务器请求资源时，Expires Header在重新请求的时候会被更新。</p><p>缺点：</p><p>由于Expires是服务器返回的一个绝对时间，存在的问题是：服务器的事件和客户端的事件可能不一致。在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改客户端时间，就能影响缓存命中的结果。所以，在http1.1中，提出了一个新的response header，就是Cache-Control。</p><ul><li>2、Cache-Control：服务器返回的相对时间。</li></ul><p>http1.1中新增的 response header。浏览器第一次请求资源之后，在接下来的相对时间之内，都可以利用本地缓存。超出这个时间之后，则不能命中缓存。重新请求时，Cache-Control会被更新。</p><p><strong>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</strong></p><ul><li>1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li><li>2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。</p><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：</p><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/4.png" alt></p><p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：</p><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/5.png" alt></p><p><strong>协商缓存是利用的是两对Header</strong></p><ul><li><p>第一对：Last-Modified、If-Modified-Since</p></li><li><p>第二对：ETag、If-None-Match</p></li></ul><h3 id="【Last-Modified，If-Modified-Since】的控制缓存的原理是："><a href="#【Last-Modified，If-Modified-Since】的控制缓存的原理是：" class="headerlink" title="【Last-Modified，If-Modified-Since】的控制缓存的原理是："></a>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</h3><ul><li>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/5.png" alt></p><ul><li>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/6.png" alt></p><ul><li>3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/7.png" alt></p><ul><li><p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p></li><li><p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p></li></ul><blockquote><p><strong>缺点：</strong><br>Last-Modified、If-Modified-Since一般来说都是非常可靠的，但面临的问题是：</p><ul><li>服务器上的资源变化了，但是最后的修改时间却没有变化。</li><li>如果服务器端在一秒内修改文件两次，但产生的Last-Modified却只有一个值。</li></ul></blockquote><p><strong>这一对header就无法解决这种情况。于是，下面这一对header出场了。</strong></p><h3 id="【ETag、If-None-Match。过程如下】的控制缓存的原理是："><a href="#【ETag、If-None-Match。过程如下】的控制缓存的原理是：" class="headerlink" title="【ETag、If-None-Match。过程如下】的控制缓存的原理是："></a>【ETag、If-None-Match。过程如下】的控制缓存的原理是：</h3><ul><li>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/8.png" alt></p><ul><li>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/9.png" alt></p><ul><li>3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</li></ul><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/10.png" alt></p><ul><li>4）浏览器收到304的响应后，就会从缓存中加载资源。</li></ul><h2 id="协商缓存管理"><a href="#协商缓存管理" class="headerlink" title="协商缓存管理"></a>协商缓存管理</h2><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:</p><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/11.png" alt></p><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。<br>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；<br>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；<br>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：</p><p><img src="//mayanming696.github.io/2018/09/26/ye-mian-xing-neng-you-hua/12.png" alt></p><p><strong>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</strong></p><h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p><ul><li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul><hr><h1 id="四、使用CDN"><a href="#四、使用CDN" class="headerlink" title="四、使用CDN"></a>四、使用CDN</h1><p>怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。<br>要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。</p><hr><h1 id="五、DNS预解析（dns-prefetch）"><a href="#五、DNS预解析（dns-prefetch）" class="headerlink" title="五、DNS预解析（dns-prefetch）"></a>五、DNS预解析（dns-prefetch）</h1><p>通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。</p><p><strong>第一步：</strong>打开或关闭DNS预解析<br>你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签：</p><pre><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></pre><p>需要说明的是，在一些高级浏览器中，页面中所有的超链接（<strong><a></a></strong>标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方）</p><p><strong>第二步：</strong>对指定的域名进行DNS预解析<br>如果我们将来可能从 <strong><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></strong> 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：</p><pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://github.com&quot;&gt;</code></pre><p>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。    </p>]]></content>
      
      
      <categories>
          
          <category> Web学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
