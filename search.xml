<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue-router参数传递</title>
      <link href="/2019/09/10/vue-router-can-shu-chuan-di/"/>
      <url>/2019/09/10/vue-router-can-shu-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="一、使用冒号（-）的形式传递参数-URL传递参数"><a href="#一、使用冒号（-）的形式传递参数-URL传递参数" class="headerlink" title="一、使用冒号（:）的形式传递参数(URL传递参数)"></a><strong>一、使用冒号（:）的形式传递参数(URL传递参数)</strong></h1><blockquote><p><strong>1，路由列表的参数设置</strong></p></blockquote><p>（1）路由列表的 path 是可以带参数的，我们在路由配置文件（router/index.js）里以冒号的形式设置参数。<br>（2）下面样例代码中，我在跳转到欢迎页面（/hello）时，带有两个参数 : <strong>id</strong> 和 <strong>userName</strong>。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/1.png" alt="路由参数"></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link to=&quot;/hello/123/hangge&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push(&quot;/hello/123/hangge&quot;);</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;&lt;div&gt;    &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;    &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数成功传递并显示。</p><hr><h1 id="二、使用-query-方式传递参数-to传递，参数显示URL"><a href="#二、使用-query-方式传递参数-to传递，参数显示URL" class="headerlink" title="二、使用 query 方式传递参数(to传递，参数显示URL)"></a><strong>二、使用 query 方式传递参数(to传递，参数显示URL)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>query 方式类似 get 传参，即通过 URL 传递参数。而路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/2.png" alt="路由参数"></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p>（1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{path:&#39;/hello&#39;, query:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    path:&#39;/hello&#39;,    query:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.query.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.query.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.query.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到点击首页链接进行跳转后，参数是自动拼接到 url 后面进行传递的。</p><hr><h1 id="三、使用-params-方式传递参数-to传递，参数不显示URL-推荐"><a href="#三、使用-params-方式传递参数-to传递，参数不显示URL-推荐" class="headerlink" title="三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)"></a><strong>三、使用 params 方式传递参数(to传递，参数不显示URL 推荐)</strong></h1><blockquote><p><strong>1，路由列表</strong></p></blockquote><p>params 方式类似于 post 传参，即传递的参数不会显示在 URL 上。同上面的 query 方式一样，路由列表的 path 不需要配置参数：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/3.png" alt="路由参数"></p><blockquote><p><strong>2，参数的传递</strong></p></blockquote><p> <strong>注意：params 只能用 name 来引入路由，而不能用 path。</strong><br> （1）如果使用 <router-link> 组件跳转的话，可以这么携带参数：</router-link></p><pre><code>    &lt;router-link :to=&quot;{name:&#39;hello&#39;, params:{id:123, userName:&#39;hangge&#39;}}&quot;&gt;    跳转到 hello    &lt;/router-link&gt;</code></pre><p>（2）如果使用 js 代码跳转的话，可以这么携带参数：</p><pre><code>    this.$router.push({    name:&#39;hello&#39;,    params:{id:123, userName:&#39;hangge&#39;}    });</code></pre><blockquote><p><strong>3，参数的获取</strong></p></blockquote><p>页面中通过 $route.params.xxx 获取传递过来的数据。</p><pre><code>    &lt;template&gt;    &lt;div&gt;        &lt;h1&gt;ID：{{ $route.params.id}}&lt;/h1&gt;        &lt;h1&gt;用户名：{{ $route.params.userName}}&lt;/h1&gt;    &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p><strong>4，运行效果</strong></p></blockquote><p>可以看到这种方式，参数的传递不会拼接到 url 后面。</p><hr><h1 id="附：使用-props-实现参数解耦"><a href="#附：使用-props-实现参数解耦" class="headerlink" title="附：使用 props 实现参数解耦"></a>附：使用 props 实现参数解耦</h1><p> 从上面的样例可以看出，当路由携带参数跳转时，页面这边通过 <strong><em>$route.params.xxx</em></strong> 或 <strong><em>$route.query.xxx</em></strong> 来获取传递过来的数据。但这样有个问题，由于组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。<br>    要解决这个问题，我们可以使用 props 将组件和路由解耦。props 共有如下三种模式。</p><blockquote><p><strong>1，布尔模式</strong></p></blockquote><p>（1）直接将路由配置中的 props 属性被设置为 true，那么参数将会被设置为组件属性。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/4.png" alt="布尔模式"></p><p>（2）然后我们页面组件这边不再需要通过 $route.params.xxx 或 $route.query.xxx 来获取传递过来的数据。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/5.png" alt="布尔模式"></p><blockquote><p><strong>2，对象模式</strong></p></blockquote><p>（1）我们可以将 props 设置为一个对象，对象内容会被设置为组件属性。这种方式常用来配置静态参数。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/6.png" alt="对象模式"></p><p>（2）然后页面组件这边获取数据方式和前面一样。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/7.png" alt="对象模式"></p><blockquote><p><strong>3，函数模式</strong></p></blockquote><p>（1）我们还可以创建一个函数返回 props，在函数中对参数值进行处理，或者将静态值与基于路由的值结合。</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/8.png" alt="函数模式"></p><p>（2）这里假设我们使用 JS 进行跳转，代码如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/9.png" alt="函数模式"></p><p>（3）目标页面组件代码，以及运行结果如下：</p><p><img src="//mayanming696.github.io/2019/09/10/vue-router-can-shu-chuan-di/10.png" alt="函数模式"></p>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router路由详解</title>
      <link href="/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/"/>
      <url>/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>基本介绍</em></p></blockquote><hr><h1 id="什么是-vue-router"><a href="#什么是-vue-router" class="headerlink" title="什么是 vue-router?"></a><strong>什么是 vue-router?</strong></h1><p> (1)<strong><em>vue-router</em></strong> 是Vue官方提供前端路由插件包，借助它我们实现可以基于路由和组件的单页面应用，路径管理器<br> (2)它与传统的页面区别在于：</p><ul><li>传统的页面应用采用的是后端路由，即通过超链接来实现页面切换和跳转的。</li><li>而在 <strong><em>vue-router</em></strong> 单页面应用中，则是通过路径之间的切换（实际上就是组件的切换）。</li></ul><hr><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a><strong>安装配置</strong></h1><p> (1)如果我们使用 <strong><em>vue-cli</em></strong> 脚手架来搭建项目，在开始配置过程会选择是否需要安装路由，具体参考我之前的这篇文章：</p><ul><li><a href="/2019/09/07/vue-quan-jia-tong/">Vue.js - 使用vue-cli搭建项目（附：详细操作步骤）</a></li></ul><p>(2)如果项目搭建时没有安装也没关系，可以执行如下命令手动安装：</p><pre><code>npm install vue-router</code></pre><hr><blockquote><p><strong>路由分类</strong></p></blockquote><h1 id="1-router-link-制作导航"><a href="#1-router-link-制作导航" class="headerlink" title="1.router-link 制作导航"></a>1.router-link 制作导航</h1><ul><li><p>router-link 是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址,当然也可以使用 v-bind 来动态设置</p></li><li><p>使用 <strong><em> <router-link></router-link></em></strong>，在 HTML5 的 History 模式下会拦截点击，避免浏览器重新加载页面。</p></li><li><p>注意：被选中的router-link将自动添加一个class属性值 <strong><em>.router-link-active</em></strong></p><pre><code>  &lt;router-link to=&quot;/&quot;&gt;[text]&lt;/router-link&gt;</code></pre></li><li><p>除了 to 属性外，<router-link> 还有一些其他常用的 prop：</router-link></p><ul><li><p><strong>tag</strong> 可以指定渲染成什么标签。比如下面渲染的结果就是 <strong><em>li</em></strong> 而不是 <strong><em>a</em></strong></p><pre><code>&lt;router-link to=&quot;/hello&quot; tag=&quot;li&quot;&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p><strong>replace</strong> 配置后不会留下 History 记录，即导航后不能用后退键返回上一个页面。</p><pre><code>&lt;router-link to=&quot;/hello&quot; replace&gt;跳转到 hello&lt;/router-link&gt;</code></pre></li><li><p>active-class</p><ul><li>当 <router-link> 对应的路由匹配成功时，会自动给当前元素设置一个名为 router-link-active 的 class。我们通常会利用它来高亮显示当前页面对应的导航菜单项。</router-link></li><li>而通过设置 active-class 可以修改默认的 class 样式名称（router-link-active），不过一般情况下我们也不需要改它，使用默认就好了。                   </li></ul></li></ul></li><li><p>to：导航路径，要填写的是你在router/index.js文件里配置的path值，<br>如果要导航到默认首页，只需要写成 to=”/“ ，</p></li><li><p>[text] ：就是我们要显示给用户的导航名称。</p></li></ul><hr><h1 id="2-router-view-用于渲染匹配到的组件"><a href="#2-router-view-用于渲染匹配到的组件" class="headerlink" title="2.router-view 用于渲染匹配到的组件"></a>2.router-view 用于渲染匹配到的组件</h1><p>会根据当前路由动态渲染不同的页面组件<br>用Vue-cli脚手架创建了项目结构，<strong><em>src文件目录下会有一个router文件夹</em></strong>,编写路由组件的地方在<br> <strong><em>编写路由组件的地方</em></strong><br><strong><em>路由的核心文件:src/router/index.js</em></strong><br> <strong><em>运行网页时，<router-view> 会根据当前路由动态渲染不同的页面组件</router-view></em></strong><br> <strong><em>而页面中的其它部分（比如本样例顶部的图片）的内容，在路由切换时，是不会发生变化的</em></strong></p><blockquote><p>下面是核心文件解析</p></blockquote><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/1.jpg" alt></p><hr><h1 id="3-vue-router配置子路由（嵌套路由、二级路由）"><a href="#3-vue-router配置子路由（嵌套路由、二级路由）" class="headerlink" title="3.vue-router配置子路由（嵌套路由、二级路由）"></a>3.vue-router配置子路由（嵌套路由、二级路由）</h1><p>在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。<br>把Hi.vue改成一个通用(母版)的模板，加入 <strong><em><router-view></router-view></em></strong>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入 <strong><em><router-view></router-view></em></strong>标签。<br><strong><em>然后路由配置如图</em></strong></p><p><img src="//mayanming696.github.io/2019/09/07/vue-js-vue-router-lu-you-xiang-jie/2.PNG" alt></p><hr><h1 id="4-使用-JS-代码进行跳转"><a href="#4-使用-JS-代码进行跳转" class="headerlink" title="4.使用 JS 代码进行跳转"></a>4.使用 JS 代码进行跳转</h1><p>除了使用 <strong><em><router-link></router-link></em></strong> 进行跳转外，我们也可以借助如下几个方法在 JavaScript 里进行页面跳转。</p><ul><li><p><strong>1，this.$router.push()</strong></p><pre><code> &lt;template&gt; &lt;div&gt;     &lt;h1&gt;首页&lt;/h1&gt;     &lt;a @click=&quot;handleRouter&quot;&gt;跳转到 hello&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: {     handleRouter() {     this.$router.push(&quot;/hello&quot;);     } } } &lt;/script&gt;</code></pre></li><li><p><strong>2，this.$router.replace()</strong><br>该方法则类似于 <router-link> 的 replace 功能，它不会向 history 添加新记录，而是替换掉当前的 history 记录。</router-link></p><pre><code>  this.$router.replace(&quot;/hello&quot;);</code></pre></li><li><p><strong>3，this.$router.go()</strong><br>该方法类似与 <strong>window.history.go()</strong>，在 history 记录中向前或者后退多少步，参数是整数。</p><pre><code>  //后退1页  this.$router.go(-1);  //前进2页  this.$router.go(2);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 全家桶</title>
      <link href="/2019/09/07/vue-quan-jia-tong/"/>
      <url>/2019/09/07/vue-quan-jia-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建项目架构-技术胖大神"><a href="#搭建项目架构-技术胖大神" class="headerlink" title="搭建项目架构,技术胖大神"></a>搭建项目架构,<strong>技术胖大神</strong></h1><hr><h1 id="Vue本地搭建"><a href="#Vue本地搭建" class="headerlink" title="Vue本地搭建"></a><strong>Vue本地搭建</strong></h1><h1 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a><strong>安装 npm</strong></h1><p>环境安装<br><strong><em>可以在命令行工具里输入</em></strong></p><blockquote><p><strong><em>npm -v</em></strong></p></blockquote><ul><li><p>检测和查询版本</p></li><li><p>下载地址 ：<strong><em><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></em></strong></p></li><li><p>用 npm命令来安装Vue-cli<br>Vue-cli是脚手架工具，作用是用配置好的模板迅速搭建一个项目工程，省去Webpack默认打包配置规则</p></li></ul><p><strong><em>在命令行输入下面命令</em></strong></p><blockquote><p><strong><em>npm install vue-cli -g</em></strong></p></blockquote><ul><li>-g 代表全局安装</li></ul><hr><h1 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a><strong>安装 vue</strong></h1><blockquote><p><strong><em>vue -V</em></strong></p></blockquote><ul><li>用来检测安装版本以及是否安装成功</li></ul><hr><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h1><blockquote><p><strong><em>$ vue init webpack 项目名称</em></strong></p></blockquote><p>(init :初始化项目)</p><ul><li>Project name：项目名称（直接回车则使用括号中默认名字）</li><li>Project description：项目描述（直接点击回车则使用默认名字）</li><li>Author：作者 (如果你有配置git的作者，他会读取。)</li><li>Runtime + Compiler: recommended for most users：运行加编译</li><li>Runtime-only：仅运行时</li><li>Install vue-router?：是否安装 vue-route（这是官方的路由，大多数情况下都使用 Y）</li><li>Use ESLint to lint your code?：是否使用 ESLint 管理代码（ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。)</li><li>Pick an ESLint preset：选择一个 ESLint 预设，编写 vue 项目时的代码风格</li><li>Setup unit tests with Karma + Mocha?：是否安装单元测试 N</li><li>Setup e2e tests with Nightwatch?：是否安装 e2e 测试 N</li></ul><blockquote><p><strong>cd 项目名称</strong></p></blockquote><p>  进入我们的vue项目目录</p><blockquote><p><strong>npm install</strong></p></blockquote><p>NPM通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）</p><ul><li>安装我们的项目依赖包，也就是安装package.json里的包</li><li>1.允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li><li>2.允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>3.允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。  </li></ul><hr><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a><strong>运行项目</strong></h1><blockquote><p><strong>npm run dev</strong></p></blockquote><p>  开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</p><hr><h1 id="打包发布项目"><a href="#打包发布项目" class="headerlink" title="打包发布项目"></a><strong>打包发布项目</strong></h1><blockquote><p><strong>npm run build</strong></p></blockquote><ul><li>在项目开发完成之后，我们可以执行如下命令来进行打包工作。</li><li>打包完成后，项目中会生成 <strong><em>dist</em></strong> 文件夹，我们只需要 <strong><em>dist</em></strong> 文件夹里的内容放到服务器上就行了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 +GitHub 搭建与关联</title>
      <link href="/2019/09/06/2019-conclusion/"/>
      <url>/2019/09/06/2019-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h1 id="搭建Hexo博客-Github"><a href="#搭建Hexo博客-Github" class="headerlink" title="搭建Hexo博客 - Github"></a>搭建Hexo博客 - Github</h1><blockquote><p>搭建Hexo博客 - Github 大体流程：</p><ul><li>1.Hexo本地搭建</li><li>2.Github 搭建</li><li>3.Hexo关联Github 并且通过本地上线到Github</li><li>4.域名与 github 绑定 </li></ul></blockquote><hr><h2 id="1-Hexo-本地搭建，韦阳大神"><a href="#1-Hexo-本地搭建，韦阳大神" class="headerlink" title="1.Hexo 本地搭建，韦阳大神"></a><strong>1.Hexo 本地搭建</strong>，<strong>韦阳大神</strong></h2><p><strong>环境安装</strong><br><strong><em>安装 Node.js </em></strong><br><strong><em>检验是否安装成功 </em></strong></p><blockquote><ul><li><strong>Win + R</strong><br> 1.<strong><em>  -node -v</em></strong><br> 2.<strong><em>  -npm -v</em></strong></li></ul></blockquote><p> 出现序列号就是安装成功<br><strong><em> 安装 Git </em></strong><br> 输入自己的项目名字，后面加入 <em>.github.io</em> 后缀，然后README 初始化也勾选上，名称一定要和前面的github名字完全一样<br><strong><em> 在设置里面选择主题 </em></strong></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><ul><li><strong>本地合适的地方新建一个文件夹</strong><br>在该目录右键点击 <strong><em>Git Bash Here</em></strong> ,打开git的控制窗口，就不用再windows 自带的运行窗口进行了</li><li><strong>定位到该目录下</strong> 安装Hexo<br>出现报错无视</li></ul><blockquote><p><strong><em>npm i hexo-cli -g</em></strong> </p></blockquote><p>安装完成后输入</p><blockquote><p><strong><em>hexo -v</em></strong></p></blockquote><p> 检测是否安装完成初始化hexo 文件<br>输入</p><blockquote><p><strong><em>hexo init</em></strong> </p></blockquote><p>初始化文件夹 ，然后安装 </p><blockquote><p><strong><em>npm install</em></strong> </p></blockquote><p>安装必备的组件,完成检测<br>输入</p><blockquote><p><strong><em>hexo g</em></strong> </p></blockquote><p>生成静态文件<br>输入</p><blockquote><p><strong><em>hexo s</em></strong></p></blockquote><p>  打开本地服务器，出现 <strong><em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em></strong> 则完成安装<br>关闭本地服务器 </p><blockquote><p><strong><em>ctrl +c </em></strong> </p></blockquote><hr><h1 id="2-连接Github与本地"><a href="#2-连接Github与本地" class="headerlink" title="2.连接Github与本地"></a>2.连接Github与本地</h1><p>对着目标文件夹右键 <strong><em>git bash</em></strong>,然后输入下面命令</p><blockquote><ul><li><strong>git config –global user.name “用户名”</strong></li></ul></blockquote><blockquote><ul><li><strong>git config –global user.email “注册邮箱”</strong></li></ul></blockquote><p>  生成密匙SSH key</p><blockquote><ul><li><strong>ssh-keygen -t rsa -C “注册邮箱”</strong></li></ul></blockquote><p>  一直默认回车 在git bash</p><blockquote><ul><li><strong>cat ~/.ssh/id_rsa.pub</strong> </li></ul></blockquote><p>  将输出内容处置到Github 账号设置里面的SSH key</p><blockquote><ul><li><strong>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></strong></li></ul></blockquote><p>  在git bash 输入出现你的用户名等信息就是成功了<br>  在博客根目录的 <strong>_config.yml</strong> 文件配置信息  </p><hr><h1 id="3-本地上传文章，发布文章"><a href="#3-本地上传文章，发布文章" class="headerlink" title="3.本地上传文章，发布文章"></a>3.本地上传文章，发布文章</h1><p>首先在博客根目录右键打开 <strong><em>git bash</em></strong> ,<br>安装一个拓展 </p><blockquote><p><strong><em>npm i hexo-deployer-git</em></strong></p></blockquote><p><strong><em>然后输入</em></strong> </p><blockquote><p><strong><em>hexo new post “名称”</em></strong>，</p></blockquote><p>新建一篇文章 <strong><em>\blog\source_posts</em></strong>的目录，可以发现下面多了一个文件夹和一个 <strong><em>.md</em></strong>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦,编写完文件后，根目录下</p><p><strong><em>输入</em></strong> </p><blockquote><p><strong><em>hexo g</em></strong></p></blockquote><p>生成静态网页，然后<br><strong><em>输入</em></strong> </p><blockquote><p><strong><em>hexo s</em></strong></p></blockquote><p> 可以本地预览效果，最后<br> <strong><em>输入</em></strong></p><blockquote><p><strong><em>hexo d</em></strong></p></blockquote><p> 上传到github上。这时打开你的github.io主页就能看到发布的文章啦</p><hr><h1 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4.域名绑定"></a>4.域名绑定</h1><p>//</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
